<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM学习（一）</title>
    <url>/2023/05/16/JVM-learning/JVMLearning/</url>
    <content><![CDATA[<p>编译器可以分为：前端编译器、JIT 编译器和AOT编译器。</p>
<span id="more"></span>
<h2 id="源代码到机器码">源代码到机器码</h2>
<h3 id="前端编译器：源代码到字节码">前端编译器：源代码到字节码</h3>
<h3 id="JIT-编译器：从字节码到机器码">JIT 编译器：从字节码到机器码</h3>
<h3 id="AOT-编译器：源代码到机器码">AOT 编译器：源代码到机器码</h3>
<h2 id="字节码文件结构">字节码文件结构</h2>
<h2 id="JVM-类加载机制">JVM 类加载机制</h2>
<p>当编译器将 Java 源码编译为字节码之后，虚拟机便可以将字节码读取进内存，从而进行解析、运行等整个过程。</p>
<p>JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：<br>
加载、验证、准备、解析、初始化、使用、卸载。</p>
<h2 id="加载">加载</h2>
<p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。</p>
<h2 id="验证">验证</h2>
<p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。<br>
因为Class文件并不要求一定要从Java源代码编译而来，可以从其他地方加载，如网络，甚至包括十六进制编辑器。</p>
<ul>
<li>
<p>文件格式验证<br>
字节流格式，是否以0xcafebabe开头，主次版本号是否在当前虚拟机处理范围内等</p>
</li>
<li>
<p>元数据验证<br>
Java语言规范验证，是否有父类，父类是否继承了不允许的类等</p>
</li>
<li>
<p>字节码验证</p>
</li>
<li>
<p>符号引用验证 ---- 链接的第三阶段：解析阶段发生</p>
</li>
</ul>
<h2 id="准备（重点）">准备（重点）</h2>
<p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。</p>
<ul>
<li>内存分配的对象。<br>
Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。</li>
<li>初始化的类型。<br>
在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。<br>
但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。</li>
</ul>
<h2 id="解析">解析</h2>
<p>通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。</p>
<h2 id="初始化（重点）">初始化（重点）</h2>
<p>在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：</p>
<h2 id="使用">使用</h2>
<h2 id="卸载">卸载</h2>
<h1>JVM 垃圾回收机制</h1>
<p>所以很多时候不同的虚拟机有不同的实现方式，下面所说的垃圾回收都是以 HotSpot 虚拟机为例。</p>
<h2 id="判断垃圾方法">判断垃圾方法</h2>
<ol>
<li>
<p>引用计数法 — 循环引用问题</p>
</li>
<li>
<p>GC Root Tracing 算法<br>
从 GC Root 出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾。GC ROOT通常包括</p>
</li>
</ol>
<ul>
<li>所有当前被加载的 Java 类</li>
<li>Java 类的引用类型静态变量</li>
<li>Java类的运行时常量池里的引用类型常量</li>
<li>JVM的一些静态数据结构里指向GC堆里的对象的引用</li>
<li>等等</li>
</ul>
<h2 id="如何进行垃圾回收">如何进行垃圾回收</h2>
<p>三种算法：标记清除算法、复制算法、标记压缩算法。</p>
<h3 id="标记清除算法">标记清除算法</h3>
<p>从名字可以看到其分为两个阶段：标记阶段和清除阶段。一种可行的实现方式是，在标记阶段，标记所有由 GC Root 触发的可达对象。此时，所有未被标记的对象就是垃圾对象。之后在清除阶段，清除所有未被标记的对象。标记清除算法最大的问题就是空间碎片问题。如果空间碎片过多，则会导致内存空间的不连续。虽说大对象也可以分配在不连续的空间中，但是效率要低于连续的内存空间。</p>
<h3 id="复制算法">复制算法</h3>
<p>复制算法的核心思想是将原有的内存空间分为两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收。该算法的缺点是要将内存空间折半，极大地浪费了内存空间。</p>
<h3 id="标记压缩算法">标记压缩算法</h3>
<p>标记压缩算法可以说是标记清除算法的优化版，其同样需要经历两个阶段，分别是：标记结算、压缩阶段。在标记阶段，从 GC Root 引用集合触发去标记所有对象。在压缩阶段，其则是将所有存活的对象压缩在内存的一边，之后清理边界外的所有空间。</p>
<h3 id="总结">总结</h3>
<p>对比一下这三种算法，可以发现他们都有各自的优点和缺点。</p>
<p>标记清除算法虽然会产生内存碎片，但是不需要移动太多对象，比较适合在存活对象比较多的情况。而复制算法虽然需要将内存空间折半，并且需要移动存活对象，但是其清理后不会有空间碎片，比较适合存活对象比较少的情况。而标记压缩算法，则是标记清除算法的优化版，减少了空间碎片。</p>
<h2 id="分代思想">分代思想</h2>
<p>分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代）</p>
<p>分代算法，就是根据 JVM 内存的不同内存区域，采用不同的垃圾回收算法。</p>
<p>例如对于存活对象少的新生代区域，比较适合采用复制算法。这样只需要复制少量对象，便可完成垃圾回收，并且还不会有内存碎片。而对于老年代这种存活对象多的区域，比较适合采用标记压缩算法或标记清除算法，这样不需要移动太多的内存对象。</p>
<h2 id="分区思想">分区思想</h2>
<p>但 JVM 中其实还有一个分区思想，即将整个堆空间划分成连续的不同小区间。<br>
分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代）</p>
<h1>JVM垃圾回收器</h1>
<p>四大类别：串行回收器、并行回收器、CMS 回收器、G1 回收器。</p>
<h2 id="串行回收器">串行回收器</h2>
<p>串行回收器是指使用单线程进行垃圾回收的回收器。</p>
<h2 id="并行回收器">并行回收器</h2>
<p>并行回收器在串行回收器的基础上做了改进，其使用多线程进行垃圾回收。</p>
<h2 id="CMS-回收器">CMS 回收器</h2>
<p>与 ParallelGC 和 ParallelOldGC 不同，CMS 回收器主要关注系统停顿时间。CMS 回收器全称为 Concurrent Mark Sweep，意为标记清除算法，其是一个使用多线程并行回收的垃圾回收器。</p>
<h2 id="G1-回收器">G1 回收器</h2>
<p>G1 回收器是 JDK 1.7 中使用的全新垃圾回收器，从长期目标来看，其是为了取代 CMS 回收器。</p>
<p>G1 回收器拥有独特的垃圾回收策略，和之前所有垃圾回收器采用的垃圾回收策略不同。从分代看，G1 依然属于分代垃圾回收器。但它最大的改变是使用了分区算法，从而使得 Eden 区、From 区、Survivor 区和老年代等各块内存不必连续。</p>
<h2 id="参考">参考</h2>
<p><a href="https://www.cnblogs.com/chanshuyi/p/jvm_serial_04_from_source_code_to_machine_code.html">https://www.cnblogs.com/chanshuyi/p/jvm_serial_04_from_source_code_to_machine_code.html</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>RequestContextHolder 学习（一）</title>
    <url>/2023/06/02/RequestContextHolder-Learning/</url>
    <content><![CDATA[<h2 id="内容总结">内容总结</h2>
<ul>
<li>如何使用<code>RequestContextHolder</code></li>
<li>如何存放<code>request，response</code></li>
<li>什么时候存放</li>
<li>为什么有两个<code>ThreadLocal</code>容器</li>
</ul>
<span id="more"></span>
<h2 id="RequestContextHolder使用">RequestContextHolder使用</h2>
<p>持有上下文的request容器，具体使用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> (String) requestAttributes.getAttribute(<span class="string">&quot;info&quot;</span>, RequestAttributes.SCOPE_REQUEST);</span><br><span class="line"><span class="comment">// 获取request</span></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) requestAttributes).getRequest();</span><br><span class="line"><span class="comment">// 获取response</span></span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> ((ServletRequestAttributes) requestAttributes).getResponse();</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> (String) request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="实现">实现</h2>
<p>RequestContextHolder的实现是基于ThreadLocal</p>
<ul>
<li>存放request的容器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder = <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Request attributes&quot;</span>);</span><br><span class="line"><span class="comment">// NamedInheritableThreadLocal 顾名思义，可被继承</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder = <span class="keyword">new</span> <span class="title class_">NamedInheritableThreadLocal</span>&lt;&gt;(<span class="string">&quot;Request context&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>什么时候存放<br>
在<code>FrameworkServlet</code>的<code>processRequestf</code>方法中，在处理请求前完成<br>
主要使用到了<code>getRequestAttributes</code>,<code>buildRequestAttributes</code>,<code>buildRequestAttributes</code>三个方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">previousLocaleContext</span> <span class="operator">=</span> LocaleContextHolder.getLocaleContext();</span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">localeContext</span> <span class="operator">=</span> buildLocaleContext(request);</span><br><span class="line">    <span class="comment">// 获取到RequestContextHolder中的 RequestAttributes实例</span></span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">previousAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="comment">// Threadlocal实际存放的是 ServletRequestAttributes的一个实例，</span></span><br><span class="line">    <span class="comment">// buildRequestAttributes 的功能是 将request和response存放在requestAttributes中</span></span><br><span class="line">    <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存setRequestAttributes到ThreadLocal中</span></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getRequestAttributes</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestAttributes <span class="title function_">getRequestAttributes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> requestAttributesHolder.get();</span><br><span class="line">    <span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">        attributes = inheritableRequestAttributesHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initContextHolders</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initContextHolders</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> LocaleContext localeContext, <span class="meta">@Nullable</span> RequestAttributes requestAttributes)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localeContext != <span class="literal">null</span>) &#123;<span class="comment">// 存放到</span></span><br><span class="line">        LocaleContextHolder.setLocaleContext(localeContext, <span class="built_in">this</span>.threadContextInheritable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="comment">// 存放到RequestContextHolder中</span></span><br><span class="line">        <span class="comment">// 根据 threadContextInheritable选择存放位置，默认值为false,即存放到requestAttributesHolder</span></span><br><span class="line">        RequestContextHolder.setRequestAttributes(requestAttributes, <span class="built_in">this</span>.threadContextInheritable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>RequestContextHolder</code>的get和set方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRequestAttributes</span><span class="params">(<span class="meta">@Nullable</span> RequestAttributes attributes, <span class="type">boolean</span> inheritable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">        resetRequestAttributes();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inheritable) &#123;</span><br><span class="line">            <span class="comment">// 设置了子类可继承时，默认false</span></span><br><span class="line">            inheritableRequestAttributesHolder.set(attributes);</span><br><span class="line">            requestAttributesHolder.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 默认时</span></span><br><span class="line">            requestAttributesHolder.set(attributes);</span><br><span class="line">            inheritableRequestAttributesHolder.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get方法</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestAttributes <span class="title function_">getRequestAttributes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认从requestAttributesHolder获取</span></span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> requestAttributesHolder.get();</span><br><span class="line">    <span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">        attributes = inheritableRequestAttributesHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="疑问">疑问</h2>
<ul>
<li>为什么有两个<code>ThreadLocal&lt;RequestAttributes&gt;</code>:<br>
<code>InheritableThreadLocal</code> 解决了父线程向子线程传递数据的问题。<br>
可通过设置<code>dispatcherServlet.setThreadContextInheritable(true);</code>使用</li>
</ul>
]]></content>
      <categories>
        <category>Source Code</category>
      </categories>
  </entry>
  <entry>
    <title>TCP/IP学习（一）</title>
    <url>/2023/04/05/Computer%20NetWork/TCPIPLearning/</url>
    <content><![CDATA[<p>目前绝大多数网络都采用TCP/IP协议，TCP/IP是目前最完整的、被普遍接受的通信协议标准</p>
<span id="more"></span>
<h2 id="第一章-TCP-IP协议基础">第一章 TCP/IP协议基础</h2>
<h3 id="网络通信协议">网络通信协议</h3>
<p>指计算机在网络中实现通信必须遵守的规则和约定，主要是对信息传输的速率、传输代码、代码结构、传输控制步骤、差错控制等做出规定并制定出标准。</p>
<h4 id="协议的组成成分">协议的组成成分</h4>
<p>语义:规定双方完成通信需要的控制信息及执行的动作<br>
语法:规定通信双方交换的数据或控制信息的格式和结构<br>
时序:规定通信双方彼此的应答关系，包括速度的匹配和顺序</p>
<h4 id="OSI参考模型">OSI参考模型</h4>
<p>顺口溜： “物联网淑慧适用”</p>
<ol>
<li>物理层：原始比特流传输，电子信号传输和硬件接口</li>
<li>链路层：物理寻址，将数据分帧并处理流控制</li>
<li>网络层：通过逻辑寻址建立结点之间的连接，包括路由和中继数据</li>
<li>传输层：常规数据传送</li>
<li>会话层：在节点间建立端连接</li>
<li>表示层：格式化数据，为应用程序提供通用接口</li>
<li>应用层：直接对用户应用程序提供服务</li>
</ol>
<p>其中<br>
通信子网：第1层----第3层<br>
网络高层：第5层----第7层</p>
<h4 id="TCP-IP">TCP/IP</h4>
<ol>
<li>网络接口层：又称网络访问层（Network Access Layer），包括OSI的物理层和链路层，负责向网络物理介质发送数据包，从网络物理介质接收数据包。TCP/IP并没有对物理层和链路层进行定义，它只是支持现有的各种底层网络技术和标准</li>
<li>网络层：网络层又称为互联网层或IP层，负责处理IP数据包的传输、路由选择、流量控制和拥塞控制。<br>
<code>协议：ARP，RARP; IP; ICMP,IGMP;</code></li>
<li>传输层为两台主机上的应用程序提供端到端的通信。<br>
<code>协议：TCP ,UDP</code></li>
<li>应用层：这个层次包括OSI的会话层、表示层和应用层，直接为特定的应用提供服务。应用层为用户提供一些常用的应用程序。<br>
<code>协议：FTP,SMTP,HTTP</code></li>
</ol>
<h2 id="aplication-layer">aplication layer</h2>
<blockquote>
<p>The application layer provides a servcices to the users;<br>
kerwords: logical connection</p>
</blockquote>
<h3 id="Application-Layer-Paradigms">Application-Layer Paradigms</h3>
<ol>
<li>client-server patadigm</li>
<li>peer-to-peer paradigm</li>
<li>Mixed Paradigm</li>
</ol>
<h4 id="Traditional-Parafigm-Client-Server">Traditional Parafigm:Client-Server</h4>
<blockquote>
<p>In this paradigm,the servivce provider is an application program,called the server process;it run continuously,waiting for another application program,called the client process,to make a connection through the Internet and ask for service.</p>
</blockquote>
<ul>
<li>Existing Problems:</li>
</ul>
<ol>
<li>The concentration of the communication load is on the shoulder of the server.</li>
</ol>
<h4 id="New-Paradigm-Peer-to-Peer">New Paradigm : Peer-to-Peer</h4>
<blockquote>
<p>A computer connected to the Internet can provide service at one time and recieve service at another time. A computer can even provide and revice services at the same time</p>
</blockquote>
<p>传统的模式中，需要一个时刻都在运行的服务器以接受随时可能由客户端发送的请求。而p2p模式下，一个电脑可以同时提供和接受服务。</p>
<ul>
<li>when：</li>
</ul>
<ol>
<li>when some computers connected to the Internet have something to share with each other.</li>
</ol>
<ul>
<li>Existing Problems:</li>
</ul>
<ol>
<li>security.</li>
<li>applicability.</li>
</ol>
<ul>
<li>Example:</li>
</ul>
<ol>
<li>BitTorrent</li>
<li>Skype</li>
<li>IPTV</li>
<li>Internet telephony.</li>
</ol>
<h4 id="Mixed-Paradigm">Mixed Paradigm</h4>
<blockquote>
<p>a light-load client-server communication can be used to find the address of the peer that can offer a service.</p>
</blockquote>
<h3 id="Application-Programming-Interface">Application Programming Interface</h3>
<blockquote>
<p>An interface in programming is a set of instructions between two entities. In this case one of the entities is the process at the aplication layer and the other is sthe operating system that encapsulates the first four layers of the TCP/IP protocol suite.</p>
</blockquote>
<p>常见API:</p>
<ol>
<li>socket interface</li>
<li>Transport Layer Interface</li>
<li>STREAM</li>
</ol>
<h4 id="Sockets">Sockets</h4>
<blockquote>
<p>it is not a physical entity like <a href="http://them.it">them.it</a> is an <a href="http://abstraction.It">abstraction.It</a> is a data structure that is created and used by the aplication program.</p>
</blockquote>
<h2 id="参考">参考</h2>
<ol>
<li>林成浴 《TCP-IP协议及其应用》</li>
<li>《computer networking a top-down approach》</li>
</ol>
]]></content>
      <categories>
        <category>computer network</category>
      </categories>
  </entry>
  <entry>
    <title>SMTP 协议学习（一）</title>
    <url>/2023/06/20/Computer%20NetWork/SMTP/</url>
    <content><![CDATA[<h2 id="内容总结">内容总结</h2>
<span id="more"></span>
<h2 id="123">123</h2>
]]></content>
      <categories>
        <category>computer network</category>
      </categories>
  </entry>
  <entry>
    <title>Java多线程学习（二）</title>
    <url>/2023/05/26/Java-multithread/Java-multithread-2/</url>
    <content><![CDATA[<h2 id="内容总结">内容总结</h2>
<ol>
<li>线程的核心原理：调度，优先级，生命周期等</li>
<li>线程的基本操作：<code>sleep()</code>，<code>interrupt()</code>等</li>
</ol>
<span id="more"></span>
<h2 id="线程的核心原理">线程的核心原理</h2>
<p>JVM将每个Java线程一对一地对应到操作系统的本地线程，彻底将线程调度委托给操作系统。</p>
<h3 id="线程的调度与时间片">线程的调度与时间片</h3>
<p>目前主流的线程调度方式：基于CPU时间片方式进行线程调度</p>
<p>线程的调度模式：</p>
<ul>
<li>分时调度模型：系统平均分配CPU的时间片，所有线程轮流占用时间片</li>
<li>抢占式调度：系统按优先级分配时间片，优先级高的先分配，如果所有线程的优先级相同，随机选择一个。</li>
</ul>
<h3 id="线程的优先级">线程的优先级</h3>
<p>Thread类中定义优先级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> priority; <span class="comment">// 优先级</span></span><br><span class="line"><span class="comment">// 优先级常量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">// 最低优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 最高优先级</span></span><br></pre></td></tr></table></figure>
<p>与优先级相关的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1. 设置优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkAccess();</span><br><span class="line">    <span class="comment">// 检查优先级范围</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &lt;= <span class="number">10</span> &amp;&amp; newPriority &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        <span class="keyword">if</span> ((g = <span class="built_in">this</span>.getThreadGroup()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setPriority0(<span class="built_in">this</span>.priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取线程的优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的生命周期">线程的生命周期</h3>
<p>Thread类中保存线程状态的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> threadStatus;</span><br></pre></td></tr></table></figure>
<p>Thread类中获取线程状态的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> VM.toThreadState(<span class="built_in">this</span>.threadStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回状态的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.State <span class="title function_">toThreadState</span><span class="params">(<span class="type">int</span> threadStatus)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((threadStatus &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.RUNNABLE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((threadStatus &amp; <span class="number">1024</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.BLOCKED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((threadStatus &amp; <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.WAITING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((threadStatus &amp; <span class="number">32</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.TIMED_WAITING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((threadStatus &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.TERMINATED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (threadStatus &amp; <span class="number">1</span>) == <span class="number">0</span> ? State.NEW : State.RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义线程状态常量的内部枚举类，共有6个枚举常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">       NEW,        <span class="comment">//新建 </span></span><br><span class="line">       RUNNABLE,   <span class="comment">// 可执行，包括操作系统的就绪、运行</span></span><br><span class="line">       BLOCKED,    <span class="comment">// 阻塞</span></span><br><span class="line">       WAITING,    <span class="comment">// 等待</span></span><br><span class="line">       TIMED_WAITING,  <span class="comment">// 限时等待</span></span><br><span class="line">       TERMINATED; <span class="comment">//终止</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">State</span><span class="params">()</span> &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>NEW</code>:<br>
创建成功但是没有调用start()方法启动的Thread线程实例都处于NEW状态。</li>
<li><code>RUNNABLE</code>:<br>
调用了<code>start()</code>方法，线程的状态；对应操作系统的就绪和执行两种状态。</li>
<li><code>BLOCKED</code>:<br>
线程进入<code>synchronized</code>方法/块，但锁被其它线程占有时。</li>
<li><code>WAITING</code>:<br>
执行<code>wait</code>方法时，不指定等待的时间。</li>
<li><code>TIMED_WAITING</code>：<br>
限时等待，可能的情况有以下几种<br>
Thread.sleep(int n) :使得当前线程进入限时等待状态，等待时间为n毫秒<br>
Object.wait():带时限的抢占对象的monitor锁</li>
<li><code>TERMINATED</code>：<br>
<code>run()</code>方法执行结束后，或者<code>run()</code>方法被异常终止</li>
</ul>
<h2 id="线程的基本操作">线程的基本操作</h2>
<h3 id="线程名">线程名</h3>
<p>略</p>
<h3 id="sleep-方法"><code>sleep()</code>方法</h3>
<p>线程状态由执行态变为计时等待(<code>TIMED_WAITING</code>)状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> var0)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数毫秒，第二个参数纳秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt;= <span class="number">0</span> &amp;&amp; nanos &lt;= <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span> &amp;&amp; millis &lt; Long.MAX_VALUE) &#123;</span><br><span class="line">            ++millis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(millis);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="interrupt-方法"><code>interrupt()</code>方法</h3>
<ul>
<li>
<p>如果线程处于运行状态，<code>t.interrupt()</code>执行后，仅仅向<code>t</code>线程发送了中断请求，<code>t</code>线程能否立刻响应则需要看具体的代码。</p>
</li>
<li>
<p>如果线程处于等待状态(Object.wait(),Thread.join(),Thread.sleep())，调用该线程立马退出阻塞，并抛出<code>InterruptedException</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;<span class="comment">// 循环检查是否被中断</span></span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中断标志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> interrupted; </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// currentThread()返回正在执行的线程信息</span></span><br><span class="line">    <span class="comment">// 如果该线程未处于运行状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> != currentThread()) &#123;</span><br><span class="line">        <span class="comment">// 此方法用于检查当前正在执行的线程是否具有修改权限。</span></span><br><span class="line">        <span class="built_in">this</span>.checkAccess();</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>.blockerLock) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> <span class="built_in">this</span>.blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 修改中断标志</span></span><br><span class="line">                <span class="built_in">this</span>.interrupted = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">this</span>.interrupt0();</span><br><span class="line">                b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程处于运行状态</span></span><br><span class="line">    <span class="comment">// 修改中断标志</span></span><br><span class="line">    <span class="built_in">this</span>.interrupted = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="join-方法"><code>join()</code>方法</h3>
<p>线程A需要将线程B的执行流程合并到自己的执行流程中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait(delay);</span><br><span class="line">            &#125; <span class="keyword">while</span>(<span class="built_in">this</span>.isAlive() &amp;&amp; (delay = millis - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; <span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (millis != <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt;= <span class="number">0</span> &amp;&amp; nanos &lt;= <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span> &amp;&amp; millis &lt; Long.MAX_VALUE) &#123;</span><br><span class="line">            ++millis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.join(millis);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="built_in">this</span>.join(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="yield-方法"><code>yield()</code>方法</h3>
<p>线程的yield（让步）操作的作用是让目前正在执行的线程放弃当前的执行，让出CPU的执行权限，使得CPU去执行其他的线程。</p>
<p>处于让步状态的JVM层面的线程状态仍然是RUNNABLE状态，但是该线程所对应的操作系统层面的线程从状态上来说会从执行状态变成就绪状态。线程在yield时，线程放弃和重占CPU的时间是不确定的，可能是刚刚放弃CPU，马上又获得CPU执行权限，重新开始执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>注</p>
<ul>
<li>yield仅能使一个线程从运行态转到就绪态，而不是阻塞态</li>
<li>yield不能保证使得当前正在运行的线程迅速切换到就绪状态</li>
<li>即使转换成功，挑选下一个线程时，就绪的线程有可能被选中，也有可能不被选中。</li>
</ul>
<h3 id="线程的daemon操作">线程的daemon操作</h3>
<p>Java中的线程分为两类：守护线程与用户线程。守护线程也称为后台线程，专门指在程序进程运行过程中，在后台提供某种通用服务的线程。比如，每启动一个JVM进程，都会在后台运行一系列的GC（垃圾回收）线程，这些GC线程就是守护线程，提供幕后的垃圾回收服务</p>
<p>实例属性和实例方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> daemon;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置是否为守护线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.daemon = on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程的守护状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isDaemon</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.daemon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程和用户线程的本质区别是：二者与JVM虚拟机进程终止的方向不同。用户线程和JVM进程是主动关系，如果用户线程全部终止，JVM虚拟机进程也随之终止；守护线程和JVM进程是被动关系，如果JVM进程终止，所有的守护线程也随之终止</p>
<p>注：</p>
<ul>
<li>守护线程必须在启动前将其守护状态设置为true，启动之后不能再将用户线程设置为守护线程，否则JVM会抛出一个InterruptedException异常。</li>
<li>守护线程存在被JVM强行终止的风险，所以在守护线程中尽量不去访问系统资源，如文件句柄、数据库连接等。守护线程被强行终止时，可能会引发系统资源操作不负责任的中断，从而导致资源不可逆的损坏</li>
<li>守护线程创建的线程也是守护线程。</li>
</ul>
]]></content>
      <categories>
        <category>Java multithread</category>
      </categories>
  </entry>
  <entry>
    <title>OAuth 2.0</title>
    <url>/2023/05/09/OAuth-2-0/OAuth-2-0/</url>
    <content><![CDATA[<p>OAuth 的核心就是向第三方应用颁发令牌<br>
四种授权方式</p>
<ol>
<li>（授权码）authorization-code</li>
<li>（隐藏式）implicit</li>
<li>（密码式）password</li>
<li>（客户端凭证）client credentials</li>
</ol>
<p>注：任何一种方式，第三方应用都必须到系统备案，以获取客户端ID（client ID）和客户端密钥（client secret）</p>
<span id="more"></span>
<h2 id="第一种方式：授权码">第一种方式：授权码</h2>
<p>最常用、最安全，适用于有后端的应用。<br>
授权码通过前端发送，令牌存储在后端，而且所有与资源服务器的通信都在后端完成。</p>
<p>授权过程：</p>
<p><img src="../../pic/process.png" alt="流程图" title="流程图"></p>
<p>（1）请求授权码<br>
A网站提供一个链接，用户点击后会跳转到B网站，授权用户数据给A网站使用<br>
链接示意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">    response_type=code&amp;     <span class="comment">// 表示要求返回授权码</span></span><br><span class="line">    client_id=CLIENT_ID&amp;    <span class="comment">// 让B知道谁在请求</span></span><br><span class="line">    redirect_uri=CALLLBACK_URL&amp; <span class="comment">// B接受或者拒绝请求后的跳转网址</span></span><br><span class="line">    scope=read      <span class="comment">// 要求的授权范围</span></span><br></pre></td></tr></table></figure>
<p>（2）返回授权码<br>
用户跳转后，B网站要求用户登录， 然后询问是否给A网站授权。用户同意后，B网站返回<code>redirect_uri</code>参数指定的网址，同时携带一个授权码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback?code=AUTHORIZATION_CODE  // code为授权码</span></span><br></pre></td></tr></table></figure>
<p>（3）请求令牌<br>
A网站拿到授权码后，可以在后端向B网站请求令牌</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line"> client_id=CLIENT_ID&amp;   </span><br><span class="line"> client_secret=CLIENT_SECRET&amp;       <span class="comment">// client_id 和client_secret参数确定A的身份</span></span><br><span class="line"> grant_type=authorization_code&amp;     <span class="comment">// 参数值为authorization_code，表示采用的授权方式为授权码</span></span><br><span class="line"> code=AUTHORIZATION_CODE&amp;           <span class="comment">// 上一步拿到的授权码</span></span><br><span class="line"> redirect_uri=CALLBACK_URL          <span class="comment">// 令牌颁发后的回调网址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（4）返回令牌<br>
B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;ACCESS_TOKEN&quot;</span><span class="punctuation">,</span>    <span class="comment">//令牌</span></span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span><span class="number">2592000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;REFRESH_TOKEN&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span><span class="string">&quot;read&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span><span class="number">100101</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span>...<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="第二种方式：隐藏式">第二种方式：隐藏式</h2>
<ol>
<li>令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</li>
<li>纯前端应用，没有后端。</li>
<li>直接向前端颁发令牌。无授权码中间步骤。<br>
（1）第一步，A网站提供链接，用户点击链接跳转B网站，授权用户数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=token&amp;  <span class="comment">//要求直接返回令牌</span></span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure>
<p>（2）第二步，B网站授权成功，跳转到A网站（通过<code>redirect_uri</code>）并以参数的形式返回令牌。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure>
<p>注意：令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在&quot;中间人攻击&quot;的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p>
<h2 id="第三种方式：密码式">第三种方式：密码式</h2>
<p>用户把用户名和密码，直接告诉该应用。<br>
该应用就使用你的密码，申请令牌。<br>
（1）第一步，A网站要求用户提供用户名和密码，向B网站请求令牌</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure>
<p>（2） 第二步，B 网站验证身份通过后，直接给出令牌。<br>
注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p>
<h2 id="第四种方式：凭证式（client-credentials）">第四种方式：凭证式（client credentials）</h2>
<p>适用于没有前端的命令行应用，即在命令行下请求令牌。<br>
这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。<br>
（1）第一步，A 应用在命令行向 B 发出请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure>
<p>第二步，B 网站验证通过以后，直接返回令牌。</p>
<h2 id="更新令牌">更新令牌</h2>
<p>令牌的有效期到了，OAuth 2.0 允许用户自动更新令牌<br>
具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET&amp;</span><br><span class="line">  refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure>
<p>B 网站验证通过以后，就会颁发新的令牌。</p>
<h2 id="参考">参考</h2>
<p><a href="https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p>
]]></content>
      <categories>
        <category>OAuth2.0</category>
      </categories>
  </entry>
  <entry>
    <title>Java多线程学习（一）</title>
    <url>/2023/05/26/Java-multithread/Java-multithread-1/</url>
    <content><![CDATA[<h2 id="内容总结">内容总结</h2>
<ol>
<li>进程和线程</li>
<li>实现线程的四种方法</li>
<li>线程的相关类和接口</li>
</ol>
<span id="more"></span>
<h2 id="进程和线程的概念">进程和线程的概念</h2>
<h3 id="进程的原理">进程的原理</h3>
<p>进程指程序的一次执行过程，具有动态性，有状态间的相互切换。<br>
一般来说一个进程包括以下内容：</p>
<ul>
<li>
<p>程序段：进程的程序指令在内存中的位置，包含所有需要执行的指令集合</p>
</li>
<li>
<p>数据段：存放进程所需要的各种数据</p>
</li>
<li>
<p>PCB:包含程序的描述信息和和控制信息，是进程存在的唯一标识</p>
</li>
</ul>
<p>其中PCB中包含以下信息：</p>
<ul>
<li>进程描述信息</li>
<li>进程调度信息</li>
<li>进程的资源信息</li>
<li>进程上下文</li>
</ul>
<h3 id="线程的原理">线程的原理</h3>
<p>线程指“进程代码段”的一次顺序执行过程。是CPU调度的基本单位，一个进程可以有多个线程。<br>
各个线程之间共享进行的内存空间、系统资源。<br>
一个线程有以下三个部分：</p>
<ul>
<li>线程描述信息</li>
<li>程序计数器</li>
<li>栈内存</li>
</ul>
<h3 id="进程和线程的区别">进程和线程的区别</h3>
<ul>
<li>进程包含线程</li>
<li>分配资源：进程，执行单位：线程</li>
<li>进程之间相互独立，线程之间不一定相互独立，共享资源：堆，方法区等</li>
<li>切换速度不同，进程切换TLB,页表等都可能替换。</li>
</ul>
<h2 id="实现线程的四种方法">实现线程的四种方法</h2>
<h3 id="继承Thred类">继承Thred类</h3>
<ol>
<li>继承<code>Thread</code>类，创建一个新的线程类</li>
<li>重写<code>run()</code>方法，将需要执行的业务代码编写<code>run()</code>方法中</li>
<li>调用<code>start()</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String tName;</span><br><span class="line"></span><br><span class="line">    MyThread(String tName)&#123;</span><br><span class="line">        <span class="built_in">this</span>.tName = tName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(tName + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testThread</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    线程0 running</span></span><br><span class="line"><span class="comment">    线程2 running</span></span><br><span class="line"><span class="comment">    线程1 running</span></span><br><span class="line"><span class="comment">    线程3 running</span></span><br><span class="line"><span class="comment">    线程4 running</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="实现Runnable接口">实现Runnable接口</h3>
<ol>
<li>定义一个新类实现<code>Runnable</code>接口</li>
<li>实现<code>Runnable</code>接口中的<code>run()</code>抽象方法</li>
<li>通过<code>Thread</code>类创建线程对象,将<code>Runnable</code>实例作为实际参数传递给<code>Thread</code>类的构造器，该构造器将<code>Runnable</code>实例赋值给自己的<code>target</code>执行目标属性</li>
<li>调用<code>start()</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    MyRunnable(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;runnable:&quot;</span> + name + <span class="string">&quot; running&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRunnable</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;线程&quot;</span> + i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    runnable:线程0 running</span></span><br><span class="line"><span class="comment">    runnable:线程1 running</span></span><br><span class="line"><span class="comment">    runnable:线程3 running</span></span><br><span class="line"><span class="comment">    runnable:线程2 running</span></span><br><span class="line"><span class="comment">    runnable:线程4 running</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在这种方式下，<code>Thread</code>类的<code>run()</code>方法实际调用了<code>target</code>的<code>run</code>方法<br>
而targert实际上正是<code>Runnable</code>类型的实例：<code>private Runnable target;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.target != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两种优雅的方式">两种优雅的方式</h4>
<ol>
<li>匿名内部类</li>
<li>Lambda表达式</li>
</ol>
<h3 id="使用Callable和FutureTask创建线程">使用Callable和FutureTask创建线程</h3>
<p>前两种方式都不能获取异步执行的结果。因为run()方法没有提供返回值</p>
<h4 id="具体步骤">具体步骤</h4>
<ol>
<li>编写一个<code>callable</code>的实现类,重写call方法</li>
<li>利用实现类的对象实例化一个<code>FutureTask</code>对象，构造方法</li>
<li>使用<code>FutureTask</code>对象实例化一个<code>Thread</code>对象，构造方法</li>
<li>调用<code>start</code>方法，<code>start</code>方法会调用<code>FutureTask</code>的<code>run</code>方法，<code>run</code>方法会调用<code>call</code>方法</li>
<li>使用<code>Futuretask</code>的<code>get</code>方法获取结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;MyCallable &quot;</span> + name + <span class="string">&quot; running&quot;</span>+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextLong();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCallable</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        FutureTask&lt;Long&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="string">&quot; &quot;</span> + i));</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;结果：&quot;</span> + futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    MyCallable  0 running, 结果：-6077239496012931430</span></span><br><span class="line"><span class="comment">    MyCallable  1 running, 结果：-7711535468802093405</span></span><br><span class="line"><span class="comment">    MyCallable  2 running, 结果：-5826319857958460016</span></span><br><span class="line"><span class="comment">    MyCallable  3 running, 结果：291853280479707483</span></span><br><span class="line"><span class="comment">    MyCallable  4 running, 结果：7280324925652476418</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="通过线程池创建线程">通过线程池创建线程</h3>
<p>Java中提供了一个静态工厂来创建不同的线程池，该静态工厂为<code>Executors</code>工厂类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExecutors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个包含三个线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">ReturnRunnable</span>(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReturnRunnable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ExecutorService接口">ExecutorService接口</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">// 只需要传入对应的的实例即可运行线程</span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; var1)</span>;</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable var1, T var2)</span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程的相关类和接口">线程的相关类和接口</h2>
<ul>
<li>函数式接口：只有一个抽象方法的接口，<code>@FunctionalInterface</code>表明这一点</li>
</ul>
<h3 id="Thread-类"><code>Thread</code> 类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String name;   <span class="comment">// 线程名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> priority;   <span class="comment">// 优先级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> daemon; <span class="comment">// 是否为守护线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> interrupted;   <span class="comment">// 是否被中断</span></span><br><span class="line">    <span class="keyword">private</span> Runnable target;    <span class="comment">// </span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals;    <span class="comment">// 线程私有变量</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals; <span class="comment">// 可以被子线程继承线程私有变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> tid;     <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> threadStatus;<span class="comment">// 线程的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>疑问：</p>
<ol>
<li>线程名为什么使用<code>volatile</code>关键字？</li>
</ol>
<h3 id="Callable-接口"><code>Callable</code> 接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Runable-接口"><code>Runable</code> 接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FutureTask-类"><code>FutureTask</code> 类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable; <span class="comment">// 线程的并发执行、任务结果的异步获取</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// 异步执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RunnableFuture-接口"><code>RunnableFuture</code> 接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口同时继承了<code>Runnable，Future</code>两个接口。<br>
第一个接口保证了它能被赋值为<code>Thread</code>的<code>target</code>变量。被<code>Thread</code>执行<br>
第二个接口保证了可以获取未来的结果</p>
<p>该接口提供了以下功能</p>
<ul>
<li>能够取消异步中执行的任务</li>
<li>能够判断异步任务是否完成</li>
<li>能够获取任务完成后的执行结果</li>
</ul>
<p>而FutureTask 提供了对该接口的具体实现</p>
<p>FutureTask的run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...... </span></span><br><span class="line">    <span class="type">Callable</span> <span class="variable">c</span> <span class="operator">=</span> <span class="built_in">this</span>.callable;</span><br><span class="line">    result = c.call();  <span class="comment">// 调用call方法并获取结果</span></span><br><span class="line">    ran = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ran) </span><br><span class="line">        <span class="built_in">this</span>.set(result);   <span class="comment">// 保存结果到outcome</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Future-接口"><code>Future</code> 接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> var1)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取结果 阻塞性质</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">//设置阻塞时限，获取结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>Java高并发核心编程 卷 2</p>
]]></content>
      <categories>
        <category>Java multithread</category>
      </categories>
  </entry>
  <entry>
    <title>Java多线程学习（三）</title>
    <url>/2023/05/27/Java-multithread/Java-multithread-3/</url>
    <content><![CDATA[<h2 id="内容总结">内容总结</h2>
<ol>
<li>线程池的架构，相关的接口和类</li>
<li>使用Executors 创建线程的方式</li>
<li>线程池的标准创建方式：使用TheadPoolExecutor构造方法</li>
<li>线程池的任务调度流程</li>
<li>阻塞队列，拒绝策略</li>
<li>关闭线程池，线程池的状态</li>
</ol>
<span id="more"></span>
<h2 id="线程池架构">线程池架构</h2>
<p><img src="../../pic/Snipaste_2023-05-27_09-54-21.png" alt="类和接口架构图"></p>
<h3 id="Executor-接口">Executor 接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Executor是Java异步目标任务的“执行者”接口，其目标是执行目标任务。</p>
<h3 id="ExecutorService-接口">ExecutorService 接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; var1)</span>;</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable var1, T var2)</span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExecutorService继承于Executor。它是Java异步目标任务的“执行者服务接”口，对外提供异步任务的接收服务。</p>
<h3 id="AbstractExecutorService-类">AbstractExecutorService 类</h3>
<p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的接口提供默认实现。</p>
<h3 id="ThreadPoolExecutor-类">ThreadPoolExecutor 类</h3>
<p>ThreadPoolExecutor是JUC线程池的核心实现类。线程的创建和终止需要很大的开销，线程池中预先提供了指定数量的可重用线程，所以使用线程池会节省系统资源，并且每个线程池都维护了一些基础的数据统计，方便线程的管理和监控</p>
<h3 id="ScheduledExecutorService">ScheduledExecutorService</h3>
<p>ScheduledExecutorService是一个接口，它继承于ExecutorService。它是一个可以完成“延时”和“周期性”任务的调度线程池接口，其功能和Timer/TimerTask类似。</p>
<h3 id="ScheduledThreadPoolExecutor">ScheduledThreadPoolExecutor</h3>
<p>ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，它提供了ScheduledExecutorService线程池接口中“延时执行”和“周期执行”等抽象调度方法的具体实现。</p>
<h3 id="Executors">Executors</h3>
<p>Executors是一个静态工厂类，它通过静态工厂方法返回ExecutorService、ScheduledExecutorService等线程池示例对象，这些静态工厂方法可以理解为一些快捷的创建线程池的方法。</p>
<h2 id="Executors创建线程的四种方式">Executors创建线程的四种方式</h2>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>newSingleThreadExecutor</td>
<td>创建只有一个线程的线程池</td>
</tr>
<tr>
<td>newFixedThreadPool</td>
<td>创建固定大小的线程池</td>
</tr>
<tr>
<td>newCachedThreadPool</td>
<td>不限制线程数量，空闲线程会得到及时回收</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>创建一个可定期或者延时执行任务的线程池</td>
</tr>
</tbody>
</table>
<h2 id="线程池的标准创建方式">线程池的标准创建方式</h2>
<p>大部分企业的开发规范都会禁止使用快捷线程池（具体原因稍后介绍），要求通过标准构造器ThreadPoolExecutor去构造工作线程池。Executors工厂类中创建线程池的快捷工厂方法实际上是调用ThreadPoolExecutor（定时任务使用ScheduledThreadPoolExecutor）线程池的构造方法完成的</p>
<h3 id="ThreadPoolExecutor的构造方法"><code>ThreadPoolExecutor</code>的构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 共<span class="number">7</span>个参数</span></span><br><span class="line"><span class="params"><span class="type">int</span> corePoolSize,   // 核心线程数，即使线程空闲也不会回收</span></span><br><span class="line"><span class="params"><span class="type">int</span> maximumPoolSize,    // 线程数的上限</span></span><br><span class="line"><span class="params"><span class="type">long</span> keepAliveTime,  TimeUnit unit,   // 线程最大空闲时间        </span></span><br><span class="line"><span class="params">BlockingQueue&lt;Runnable&gt; workQueue, // 排队队列</span></span><br><span class="line"><span class="params">ThreadFactory threadFactory,    // 新线程的产生方式</span></span><br><span class="line"><span class="params">RejectedExecutionHandler handler    // 拒绝策略</span></span><br><span class="line"><span class="params"> )</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.ctl = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(-<span class="number">536870912</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">this</span>.mainLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="built_in">this</span>.workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    <span class="built_in">this</span>.termination = <span class="built_in">this</span>.mainLock.newCondition();</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &gt;= <span class="number">0</span> &amp;&amp; maximumPoolSize &gt; <span class="number">0</span> &amp;&amp; maximumPoolSize &gt;= corePoolSize &amp;&amp; keepAliveTime &gt;= <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (workQueue != <span class="literal">null</span> &amp;&amp; threadFactory != <span class="literal">null</span> &amp;&amp; handler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">            <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">            <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">            <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">            <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">            <span class="built_in">this</span>.handler = handler;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参数">参数</h4>
<h5 id="核心和最大线程数">核心和最大线程数</h5>
<p>参数<code>corePoolSize</code>用于设置核心（Core）线程池数量,参数<code>maximumPoolSize</code>用于设置最大线程数量。规则:</p>
<p>(1) 当在线程池接收到新任务，并且当前工作线程数少于corePoolSize时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求，直到线程数达到corePoolSize。</p>
<p>(2) 如果当前工作线程数多于corePoolSize数量，但小于maximumPoolSize数量，那么仅当任务排队队列已满时才会创建新线程</p>
<p>(3) 当maximumPoolSize被设置为无界值（如Integer.MAX_VALUE）时，线程池可以接收任意数量的并发任务。</p>
<p>(4) corePoolSize和maximumPoolSize不仅能在线程池构造时设置，也可以调用setCorePoolSize()和setMaximumPoolSize()两个方法进行动态更改</p>
<h5 id="BlockingQueue">BlockingQueue</h5>
<p>BlockingQueue（阻塞队列）的实例用于暂时接收到的异步任务，如果线程池的核心线程都在忙，那么所接收到的目标任务缓存在阻塞队列中。</p>
<h5 id="keepAliveTime">keepAliveTime</h5>
<p>线程构造器的keepAliveTime（空闲线程存活时间）参数用于设置池内线程最大Idle（空闲）时长（或者说保活时长），如果超过这个时间，默认情况下Idle、非Core线程会被回收。</p>
<p>同时JDK提供了 <code>public void setKeepAliveTime(long time, TimeUnit unit)</code> 方法动态调整存活时间</p>
<p>默认情况下，Idle超时策略仅适用于存在超过corePoolSize线程的情况。但若调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，并且传入了参数true，则keepAliveTime参数所设置的Idle超时策略也将被应用于核心线程。</p>
<h2 id="向线程池提交任务的两种方式">向线程池提交任务的两种方式</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executor 接口中的方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable var1)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ExecutorService 接口中的方法</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>; </span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>
<h3 id="区别">区别</h3>
<ul>
<li>
<p>二者接受的参数不一样</p>
</li>
<li>
<p>submit有返回值，execute没有</p>
</li>
<li>
<p>submit()方便Exception处理<br>
execute()方法在启动任务执行后，任务执行过程中可能发生的异常调用者并不关心。而通过submit()方法返回的Future对象（异步执行实例），可以进行异步执行过程中的异常捕获。</p>
</li>
</ul>
<h2 id="线程池的任务调度流程">线程池的任务调度流程</h2>
<ol>
<li>
<p>如果当前工作线程数量小于核心线程数量，执行器总是优先创建一个任务线程，而不是从线程队列中获取一个空闲线程。</p>
</li>
<li>
<p>果线程池中总的任务数量大于核心线程池数量，新接收的任务将被加入阻塞队列中，一直到阻塞队列已满。在核心线程池数量已经用完、阻塞队列没有满的场景下，线程池不会为新任务创建一个新线程。</p>
</li>
<li>
<p>当完成一个任务的执行时，执行器总是优先从阻塞队列中获取下一个任务，并开始执行，一直到阻塞队列为空，其中所有的缓存任务被取光。</p>
</li>
<li>
<p>在核心线程池数量已经用完、阻塞队列也已经满了的场景下，如果线程池接收到新的任务，将会为新任务创建一个线程（非核心线程），并且立即开始执行新任务。</p>
</li>
<li>
<p>在核心线程都用完、阻塞队列已满的情况下，一直会创建新线程去执行新任务，直到池内的线程总数超出maximumPoolSize。如果线程池的线程总数超过maximumPoolSize，线程池就会拒绝接收任务，当新任务过来时，会为新任务执行拒绝策略。</p>
</li>
</ol>
<p>总的流程如下<br>
<img src="../../pic/Snipaste_2023-05-27_10-55-17.png" alt="流程"></p>
<h2 id="ThreadFactory（线程工厂）">ThreadFactory（线程工厂）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    Thread <span class="title function_">newThread</span><span class="params">(Runnable var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建新线程池时可以指定将要使用的ThreadFactory实例。只不过，如果没有指定的话，就会使用Executors.defaultThreadFactory默认实例。使用默认的线程工厂实例所创建的线程全部位于同一个ThreadGroup（线程组）中，具有相同的NORM_PRIORITY（优先级为5），而且都是非守护进程状态。</p>
<h2 id="任务阻塞队列-待完成">任务阻塞队列(待完成)</h2>
<h2 id="调度器的钩子方法">调度器的钩子方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池的拒绝策略">线程池的拒绝策略</h2>
<p>有两种情况：</p>
<ul>
<li>线程池已经被关闭</li>
<li>工作队列已满且maximumPoolSize已满</li>
</ul>
<p>线程池都会调用RejectedExecutionHandler实例的rejectedExecution方法。RejectedExecutionHandler是拒绝策略的接口，JUC为该接口提供了以下几种实现</p>
<ul>
<li>
<p>AbortPolicy：拒绝策略。<br>
使用该策略时，如果线程池队列满了，新任务就会被拒绝，并且抛出RejectedExecutionException异常。该策略是线程池默认的拒绝策略。</p>
</li>
<li>
<p>DiscardPolicy：抛弃策略。<br>
该策略是AbortPolicy的Silent（安静）版本，如果线程池队列满了，新任务就会直接被丢掉，并且不会有任何异常抛出。</p>
</li>
<li>
<p>DiscardOldestPolicy：抛弃最老任务策略。<br>
抛弃最老任务策略，也就是说如果队列满了，就会将最早进入队列的任务抛弃，从队列中腾出空间，再尝试加入队列。因为队列是队尾进队头出，队头元素是最老的，所以每次都是移除队头元素后再尝试入队。</p>
</li>
<li>
<p>CallerRunsPolicy：调用者执行策略。<br>
调用者执行策略。在新任务被添加到线程池时，如果添加失败，那么提交任务线程会自己去执行该任务，不会使用线程池中的线程去执行新任务。</p>
</li>
<li>
<p>自定义策略。</p>
</li>
</ul>
<h2 id="线程池的关闭">线程池的关闭</h2>
<h3 id="线程池的状态">线程池的状态</h3>
<p>共5种状态，定义在ThreadPoolExecutor中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span> <span class="operator">=</span> -<span class="number">536870912</span>;  <span class="comment">// 线程池创建后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span> <span class="operator">=</span> <span class="number">0</span>;          <span class="comment">// 调用shutdown方法后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span> <span class="operator">=</span> <span class="number">536870912</span>;      <span class="comment">// 调用shutdownNow方法后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span> <span class="operator">=</span> <span class="number">1073741824</span>;  <span class="comment">// 等待线程池的所有工作线程停止，工作队列清空之后，线程池状态会从STOP转变为TIDYING。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span> <span class="number">1610612736</span>; <span class="comment">// 执行完terminated()钩子方法之后，线程池状态从TIDYING转变为TERMINATED。</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭线程池的方法">关闭线程池的方法</h3>
<p>共三种<br>
（1）shutdown<br>
（2）shutdownNow<br>
（3）awaitTermination</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();<span class="comment">// 加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查权限</span></span><br><span class="line">        <span class="built_in">this</span>.checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池状态</span></span><br><span class="line">        <span class="built_in">this</span>.advanceRunState(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 中断空闲线程</span></span><br><span class="line">        <span class="built_in">this</span>.interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 钩子函数，用于清理资源</span></span><br><span class="line">        <span class="built_in">this</span>.onShutdown();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();    <span class="comment">// 加锁</span></span><br><span class="line"></span><br><span class="line">    List tasks;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.checkShutdownAccess();</span><br><span class="line">        <span class="built_in">this</span>.advanceRunState(<span class="number">536870912</span>);    <span class="comment">// 设置状态STOP</span></span><br><span class="line">        <span class="built_in">this</span>.interruptWorkers();    <span class="comment">// 中断所有线程</span></span><br><span class="line">        tasks = <span class="built_in">this</span>.drainQueue();  <span class="comment">// 丢弃工作队列的剩余任务</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> var7;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">while</span>(runStateLessThan(<span class="built_in">this</span>.ctl.get(), <span class="number">1610612736</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    var7 = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> var7;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nanos = <span class="built_in">this</span>.termination.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var7 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> var7;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="优雅关闭线程池">优雅关闭线程池</h3>
<p>（1）执行shutdown()方法，拒绝新任务的提交，并等待所有任务有序地执行完毕。<br>
（2）执行awaitTermination(long timeout,TimeUnit unit)方法，指定超时时间，判断是否已经关闭所有任务，线程池关闭完成。<br>
（3）如果awaitTermination()方法返回false，或者被中断，就调用shutDownNow()方法立即关闭线程池所有任务。<br>
（4）补充执行awaitTermination(long timeout,TimeUnit unit)方法，判断线程池是否关闭完成。如果超时，就可以进入循环关闭，循环一定的次数（如1000次），不断关闭线程池，直到其关闭或者循环结束。</p>
<h3 id="注册JVM钩子函数自动关闭线程池（待完成）">注册JVM钩子函数自动关闭线程池（待完成）</h3>
<h2 id="Executors快捷创建线程池的潜在问题">Executors快捷创建线程池的潜在问题</h2>
<h3 id="使用Executors创建“固定数量的线程池”的潜在问题">使用Executors创建“固定数量的线程池”的潜在问题</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0L</span>, </span><br><span class="line">    TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Executors创建“固定数量的线程池”的潜在问题主要存在于其workQueue上，其值为LinkedBlockingQueue（无界阻塞队列）。如果任务提交速度持续大于任务处理速度，就会造成队列中大量的任务等待。如果队列很大，很有可能导致JVM出现OOM（Out Of Memory）异常，即内存资源耗尽。</p>
<h3 id="使用Executors创建“单线程化线程池”的潜在问题">使用Executors创建“单线程化线程池”的潜在问题</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span>(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用FinalizableDelegatedExecutorService对该“固定大小的线程池”进行包装，这一层包装的作用是防止线程池的corePoolSize被动态地修改。</p>
<p>使用Executors创建的“单线程化线程池”与“固定大小的线程池”一样，其潜在问题仍然存在于其workQueue属性上，该属性的值为LinkedBlockingQueue（无界阻塞队列）。如果任务提交速度持续大于任务处理速度，就会造成队列大量阻塞。如果队列很大，很有可能导致JVM的OOM异常，甚至造成内存资源耗尽。</p>
<h3 id="使用Executors创建“可缓存线程池”的潜在问题">使用Executors创建“可缓存线程池”的潜在问题</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Executors创建的“可缓存线程池”的潜在问题存在于其最大线程数量不设限上。由于其maximumPoolSize的值为Integer.MAX_VALUE（非常大），可以认为可以无限创建线程，如果任务提交较多，就会造成大量的线程被启动，很有可能造成OOM异常，甚至导致CPU线程资源耗尽。</p>
<h3 id="用Executors创建“可调度线程池”的潜在问题">用Executors创建“可调度线程池”的潜在问题</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Executors创建的“可缓存线程池”的潜在问题存在于其最大线程数量不设限上。由于其线程数量不设限，如果到期任务太多，就会导致CPU的线程资源耗尽。</p>
]]></content>
      <categories>
        <category>Java multithread</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity 学习(一)</title>
    <url>/2023/06/04/Spring%20Security/SpringSecurity-Learning-1/</url>
    <content><![CDATA[<h2 id="内容总结">内容总结</h2>
<span id="more"></span>
<h2 id="使用默认配置">使用默认配置</h2>
<ul>
<li>导入依赖</li>
</ul>
<p>SpringBoot导入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>我的SpringBoot的版本为 <code>&lt;version&gt;3.1.0&lt;/version&gt;</code><br>
SpringSecurity 的版本为 <code>&lt;spring-security.version&gt;6.1.0&lt;/spring-security.version&gt;</code></p>
<ul>
<li>点击启动，控制台输出自动生成的密码，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Using generated security password: ab189335-6fc0-4f1f-88ae-85d1962d3a91</span><br></pre></td></tr></table></figure>
<ul>
<li>访问配置的网址，输入用户名user，和以上密码即可</li>
</ul>
<h3 id="控制台输出">控制台输出</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2023</span>-<span class="number">06</span>-04T15:<span class="number">51</span>:<span class="number">36.151</span>+08:<span class="number">00</span>  INFO <span class="number">24324</span> --- [           main] o.s.s.web.DefaultSecurityFilterChain     :</span><br><span class="line"> Will secure any request with [</span><br><span class="line">    org.springframework.security.web.session.DisableEncodeUrlFilter@6dded900, </span><br><span class="line">    org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter<span class="meta">@d504137</span>, </span><br><span class="line">    org.springframework.security.web.context.SecurityContextHolderFilter@5f409872, </span><br><span class="line">    org.springframework.security.web.header.HeaderWriterFilter@2ff498b0, </span><br><span class="line">    org.springframework.security.web.csrf.CsrfFilter@78318ac2, </span><br><span class="line">    org.springframework.security.web.authentication.logout.LogoutFilter@<span class="number">75527e36</span>, </span><br><span class="line">    org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@1b47b7f5,</span><br><span class="line">    org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@98637a2, </span><br><span class="line">    org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@<span class="number">8432469</span>, </span><br><span class="line">    org.springframework.security.web.authentication.www.BasicAuthenticationFilter@6ef1c3f7, </span><br><span class="line">    org.springframework.security.web.savedrequest.RequestCacheAwareFilter@472c9f88, </span><br><span class="line">    org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@7afbf2a0,</span><br><span class="line">    org.springframework.security.web.authentication.AnonymousAuthenticationFilter<span class="meta">@e4ca109</span>,</span><br><span class="line">    org.springframework.security.web.access.ExceptionTranslationFilter@108b121f,</span><br><span class="line">    org.springframework.security.web.access.intercept.AuthorizationFilter@7e050be1</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>可以从以上输出看到，Spring Security本质上是一个过滤器链。默认情况下所有的过滤器都存放在<code>DefaultSecurityFilterChain</code>中。</p>
<h2 id="实现过滤器链的相关类和接口">实现过滤器链的相关类和接口</h2>
<h3 id="DefaultSecurityFilterChain"><code>DefaultSecurityFilterChain</code></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DefaultSecurityFilterChain</span> <span class="keyword">implements</span> <span class="title class_">SecurityFilterChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Filter&gt; filters; <span class="comment">// 存放过滤器的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultSecurityFilterChain</span><span class="params">(RequestMatcher requestMatcher, Filter... filters)</span> &#123; <span class="comment">//初始化过滤器链</span></span><br><span class="line">    <span class="built_in">this</span>(requestMatcher, Arrays.asList(filters));   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultSecurityFilterChain</span><span class="params">(RequestMatcher requestMatcher, List&lt;Filter&gt; filters)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (filters.isEmpty()) &#123;</span><br><span class="line">        logger.info(LogMessage.format(<span class="string">&quot;Will not secure %s&quot;</span>, requestMatcher));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(LogMessage.format(<span class="string">&quot;Will secure %s with %s&quot;</span>, requestMatcher, filters));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.requestMatcher = requestMatcher;</span><br><span class="line">    <span class="built_in">this</span>.filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(filters);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>DefaultSecurityFilterChain</code>实现了<code>SecurityFilterChain</code>接口，并且该接口只有两个方法</p>
<h3 id="SecurityFilterChain"><code>SecurityFilterChain</code></h3>
<p>这个接口的介绍为：</p>
<blockquote>
<p>Defines a filter chain which is capable of being matched against an HttpServletRequest. in order to decide - whether it applies to that request<br>
Used to configure a FilterChainProxy.</p>
</blockquote>
<p>大概意思就是说，该接口定义了一个能够匹配HttpServletRequest的过滤器链。<br>
这个接口被用于配置<code>FilterChainProxy</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityFilterChain</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(HttpServletRequest request)</span>;    <span class="comment">//  根据request判断与匹配过滤器链匹配</span></span><br><span class="line">    List&lt;Filter&gt; <span class="title function_">getFilters</span><span class="params">()</span>;      <span class="comment">// 获取过滤器List</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法在<code>DefaultSecurityFilterChain</code>的实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Filter&gt; <span class="title function_">getFilters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.filters;    <span class="comment">// 直接返回过滤器的List</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.requestMatcher.matches(request);    <span class="comment">// 调用requestMatcher的match方法进行判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>requestMatcher</code> 的类型 <code>RequestMatcher</code>是一个接口</p>
<h3 id="RequestMatcher">RequestMatcher</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestMatcher</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">    <span class="keyword">default</span> MatchResult <span class="title function_">matcher</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> matches(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchResult</span>(match, Collections.emptyMap());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MatchResult</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> match;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; variables;</span><br><span class="line">        MatchResult(<span class="type">boolean</span> match, Map&lt;String, String&gt; variables) &#123;</span><br><span class="line">            <span class="built_in">this</span>.match = match;</span><br><span class="line">            <span class="built_in">this</span>.variables = variables;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FilterChainProxy">FilterChainProxy</h3>
<p>上面提到了<code>SecurityFilterChain</code>被用于配置<code>FilterChainProxy</code>, 那到它是干什么？先看它的介绍:</p>
<blockquote>
<p>Delegates Filter requests to a list of Spring-managed filter beans.<br>
将请求委托给 Spring 管理的过滤器 Bean 列表。<br>
也就是说该类管理着上文提到的过滤器链</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterChainProxy</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类继承了<code>GenericFilterBean</code>,而<code>GenericFilterBean</code>实现了<code>Filter</code>接口。所以这个类也是一个过滤器。所以看一下这个类的<code>doFilter</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">        doFilterInternal(request, response, chain); <span class="comment">// 执行过滤功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法执行过程中实际调用了<code>doFilterInternal</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...... </span></span><br><span class="line">    <span class="comment">// firewallRequest 是经过封装的request请求</span></span><br><span class="line">    List&lt;Filter&gt; filters = getFilters(firewallRequest);</span><br><span class="line">    <span class="keyword">if</span> (filters == <span class="literal">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// decorate方法返回一个VirtualFilterChain，然后其执行doFilter方法</span></span><br><span class="line">    <span class="comment">// doFilter方法会调用所有的Filter进行过滤</span></span><br><span class="line">    <span class="built_in">this</span>.filterChainDecorator.decorate(reset, filters).doFilter(firewallRequest, firewallResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
  </entry>
  <entry>
    <title>Java多线程学习（四）</title>
    <url>/2023/05/28/Java-multithread/Java-multithread-4/</url>
    <content><![CDATA[<h2 id="内容总结">内容总结</h2>
<ol>
<li>如何确定线程池的数目</li>
<li>ThreadLocal的源码分析，使用场景</li>
</ol>
<span id="more"></span>
<h2 id="确定线程池的线程数目">确定线程池的线程数目</h2>
<h3 id="按照任务类型分类">按照任务类型分类</h3>
<h4 id="IO密集型">IO密集型</h4>
<p>由于IO密集型任务的CPU使用率较低，导致线程空余时间很多，因此通常需要开CPU核心数两倍的线程。当IO线程空闲时，可以启用其他线程继续使用CPU，以提高CPU的使用率。</p>
<h4 id="CPU密集型">CPU密集型</h4>
<p>由于IO密集型任务的CPU使用率较低，导致线程空余时间很多，因此通常需要开CPU核心数两倍的线程。当IO线程空闲时，可以启用其他线程继续使用CPU，以提高CPU的使用率。</p>
<h4 id="混合型">混合型</h4>
<p><code>最佳线程数 = ((线程等待时间+线程CPU时间) / 线程CPU时间) * CPU核数</code></p>
<h2 id="ThreadLocal原理">ThreadLocal原理</h2>
<p>在Java的多线程并发执行过程中，为了保证多个线程对变量的安全访问，可以将变量放到ThreadLocal类型的对象中，使变量在每个线程中都有独立值，不会出现一个线程读取变量时被另一个线程修改的现象。ThreadLocal类通常被翻译为“线程本地变量”类或者“线程局部变量”类。</p>
<h3 id="基本使用">基本使用</h3>
<p>通常使用以下三个方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>get(T value)</td>
<td></td>
</tr>
<tr>
<td>T set</td>
<td></td>
</tr>
<tr>
<td>remove</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="使用场景">使用场景</h3>
<h4 id="线程隔离">线程隔离</h4>
<p>ThreadLocal在线程隔离的常用案例为：可以为每个线程绑定一个用户会话信息、数据库连接、HTTP请求等，这样一个线程所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<p>数据库连接共享：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title function_">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException &#123;  </span><br><span class="line">    <span class="type">Session</span> <span class="variable">s</span> <span class="operator">=</span> (Session) threadSession.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 没有创建session时候</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取session</span></span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            <span class="comment">// 保存到threadLocal中</span></span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InfrastructureException</span>(ex);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个session是共享时，其他线程使用结束可能会关闭session</p>
<h3 id="跨函数传递数据">跨函数传递数据</h3>
<p>在“跨函数传递数据”场景中使用ThreadLocal的典型案例为：可以为每个线程绑定一个Session（用户会话）信息，这样一个线程所有调用到的代码都可以非常方便地访问这个本地会话，而不需要通过参数传递</p>
<p>（1）用来传递请求过程中的用户ID。<br>
（2）用来传递请求过程中的用户会话（Session）。<br>
（3）用来传递HTTP的用户请求实例HttpRequest。<br>
（4）其他需要在函数之间频繁传递的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crazymaker.springcloud.common.context;</span><br><span class="line"><span class="comment">// 省略import</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionHolder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// session id，线程本地变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; sidLocal =</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(<span class="string">&quot;sidLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户信息，线程本地变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; sessionUserLocal =</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(<span class="string">&quot;sessionUserLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// session，线程本地变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;HttpSession&gt; sessionLocal = </span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(<span class="string">&quot;sessionLocal&quot;</span>);</span><br><span class="line"><span class="comment">// 省略其他  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *保存session在线程本地变量中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setSession</span><span class="params">(HttpSession session)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sessionLocal.set(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得绑定在线程本地变量中的session </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HttpSession <span class="title function_">getSession</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> sessionLocal.get();</span><br><span class="line">        Assert.notNull(session, <span class="string">&quot;session未设置&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocal-的方法">ThreadLocal 的方法</h3>
<h4 id="set-T-value-方法">set(T value)方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从当前线程获取ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 也就是说ThradLocalMap实际存放在线程Thread中</span></span><br><span class="line">    <span class="comment">// ThreadLocal.ThreadLocalMap threadLocals;</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="comment">// 存放数据，键为threadLocal,值为value</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="get-方法">get()方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="remove-方法">remove 方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocalMap-源码分析">ThreadLocalMap 源码分析</h3>
<h4 id="类的定义">类的定义</h4>
<p><code>ThreadLocalMap</code> 是<code>ThreadLocal</code>的一个静态内部类,其实例被保存在<code>Thread</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// Map的条目数组，作为Hash表使用</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 扩容因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Set方法">Set方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key的hashcode,找到key在数组上的槽点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从槽点i开始向后循环搜索，找空余槽点或者找现有槽点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.refersTo(key)) &#123; <span class="comment">// 找到现有槽点</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.refersTo((Object)<span class="literal">null</span>)) &#123;<span class="comment">// 找到异常槽点，GC了，重设key和value</span></span><br><span class="line">            <span class="built_in">this</span>.replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到现有槽点，增加新的entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++<span class="built_in">this</span>.size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理key为null的无效entry</span></span><br><span class="line">    <span class="comment">// 没有可清理的entry,并且现有条目数量大于扩容因子值，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= <span class="built_in">this</span>.threshold) &#123;</span><br><span class="line">        <span class="built_in">this</span>.rehash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadLocalMap的key使用了弱引用">ThreadLocalMap的key使用了弱引用</h4>
<p>仅有弱引用（Weak Reference）指向的对象只能生存到下一次垃圾回收之前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        <span class="built_in">this</span>.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>发生GC，key一定为null吗？<br>
不一定，比如说如果当前ThreadLocal同时还是强引用时</li>
<li>为什么要使用弱引用？<br>
函数的栈帧出栈后，如果ThreadLocalMap的键是强引用，会造成内存泄漏的问题</li>
</ul>
<h3 id="使用原则">使用原则</h3>
<ul>
<li>
<p>尽量使用private static final修饰ThreadLocal实例。使用private与final修饰符主要是为了尽可能不让他人修改、变更ThreadLocal变量的引用，使用static修饰符主要是为了确保ThreadLocal实例的全局唯一。</p>
</li>
<li>
<p>ThreadLocal使用完成之后务必调用remove()方法。这是简单、有效地避免ThreadLocal引发内存泄漏问题的方法。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java multithread</category>
      </categories>
  </entry>
  <entry>
    <title>ArrayList源码分析</title>
    <url>/2023/05/24/collections/ArrayList-source-code/</url>
    <content><![CDATA[<p>JDK版本 :<br>
openjdk 17.0.7 2023-04-18 LTS<br>
OpenJDK Runtime Environment Corretto-17.0.7.7.1 (build 17.0.7+7-LTS)<br>
OpenJDK 64-Bit Server VM Corretto-17.0.7.7.1 (build 17.0.7+7-LTS, mixed mode, sharing)</p>
<span id="more"></span>
<h2 id="构造器">构造器</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// List默认大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];    <span class="comment">// 当给定元素数目（集合，容量）&lt;=0的时使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];    <span class="comment">// 无参构造的时候使用</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// 存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;   <span class="comment">// 存放元素的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-扩容机制分析">1. 扩容机制分析</h2>
<h3 id="添加一个元素有3个add方法">添加一个元素有3个add方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length) &#123;</span><br><span class="line">        <span class="comment">// 如果s(list的长度)等于数组的长度时，即存储空间已满</span></span><br><span class="line">        <span class="comment">// 进行扩容</span></span><br><span class="line">        elementData = <span class="built_in">this</span>.grow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    <span class="built_in">this</span>.size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ++<span class="built_in">this</span>.modCount;</span><br><span class="line">    <span class="built_in">this</span>.add(e, <span class="built_in">this</span>.elementData, <span class="built_in">this</span>.size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查下标是否合法</span></span><br><span class="line">    <span class="built_in">this</span>.rangeCheckForAdd(index);</span><br><span class="line">    ++<span class="built_in">this</span>.modCount;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看起来很复杂，功能也是判断数组长度和元素个数是否相等</span></span><br><span class="line">    <span class="comment">// 如果相等则进行扩容</span></span><br><span class="line">    <span class="comment">// 疑问: 为什么以这样的方式判断是否已满，而不是直接</span></span><br><span class="line">    <span class="comment">// this.size === this.elementDate.length的方式判断</span></span><br><span class="line">    <span class="keyword">if</span> ((s = <span class="built_in">this</span>.size) == (elementData = <span class="built_in">this</span>.elementData).length) &#123;</span><br><span class="line">        elementData = <span class="built_in">this</span>.grow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将elementDate 中以index为起始位置的内容拷贝到elementDate以index +1 的位置，拷贝长度为 s-index</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="built_in">this</span>.size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="grow-方法">grow()方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">// 原来的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> <span class="built_in">this</span>.elementData.length;</span><br><span class="line">    <span class="comment">// 如果容量&lt;=0且，该list没有添加任何元素时候</span></span><br><span class="line">    <span class="comment">// 扩容，最小的容量为10，超过10的时候为minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &lt;= <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(<span class="number">10</span>, minCapacity)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是第一次添加元素</span></span><br><span class="line">        <span class="comment">// 确定新的容量，在添加一个元素的add方法中，扩容为原来的1.5倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新数组并复制元素，并返回新数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elementData = Arrays.copyOf(<span class="built_in">this</span>.elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.grow(<span class="built_in">this</span>.size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth);</span><br><span class="line">     <span class="comment">// list的大容量为int的最大值</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= <span class="number">2147483639</span> ? prefLength : hugeLength(oldLength, minGrowth);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加一堆元素">添加一堆元素</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        ++<span class="built_in">this</span>.modCount;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] elementData;</span><br><span class="line">            <span class="type">int</span> s;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (numNew &gt; (elementData = <span class="built_in">this</span>.elementData).length - (s = <span class="built_in">this</span>.size)) &#123;</span><br><span class="line">                <span class="comment">// 剩余的容量不足，扩容，有可能非1.5倍</span></span><br><span class="line">                elementData = <span class="built_in">this</span>.grow(s + numNew);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">            <span class="built_in">this</span>.size = s + numNew;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rangeCheckForAdd(index);</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        ++<span class="built_in">this</span>.modCount;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] elementData;</span><br><span class="line">            <span class="type">int</span> s;</span><br><span class="line">            <span class="keyword">if</span> (numNew &gt; (elementData = <span class="built_in">this</span>.elementData).length - (s = <span class="built_in">this</span>.size)) &#123;</span><br><span class="line">                elementData = <span class="built_in">this</span>.grow(s + numNew);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> s - index;</span><br><span class="line">            <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">            <span class="built_in">this</span>.size = s + numNew;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<ol>
<li>空List添加第一个元素s时，扩容到长度为10</li>
<li>非空且需要扩容的时候有两种情况
<ol>
<li>添加一个元素：<br>
长度为原来的1.5倍</li>
<li>添加一堆元素：<br>
长度最小为原来的1.5倍</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>collections</category>
      </categories>
  </entry>
  <entry>
    <title>一些问题</title>
    <url>/2023/05/19/someQuestions/Questions-0/</url>
    <content><![CDATA[<p>记录一些想到的问题</p>
<h2 id="1-什么是Java方法重写">1.什么是Java方法重写</h2>
<p>要求遵循“两同两大一小”</p>
<ul>
<li>“两同” 指方法名相同，形参列表相同</li>
<li>“两小” 指子类方法返回值类型应该比父类返回值类型更小，子类方法声明抛出的异常类应该比父类方法抛出的更小或者相等</li>
<li>“一大” 指子类方法的访问权限应该比父类方法的访问权限更大或者相等。</li>
</ul>
<span id="more"></span>
<p>这是因为如果返回值类型更大，则可能会造成父类对象无法完全转换为子类对象，从而导致编译错误和运行时异常。<br>
重写还有一条规则是访问控制符必须高于父类？那是因为为了多态的实现。有时候父类需要上转型引用子类的方法实现多态，这就导致子类方法的访问控制符必须高于父类，否则子类里写成了private，父类还怎么访问？</p>
<h2 id="2-对象实例都在Java堆中吗？">2.对象实例都在Java堆中吗？</h2>
<p>不一定，是几乎所有的实例都在堆中。<br>
JIT编译除了具有缓存的功能外，还会对代码做各种优化，其中有逃逸分析功能。<br>
如果逃逸分析发现一个对象不会逃逸出当前方法或线程，则可以将该对象存储在栈上而不是堆上。由于栈是局部的，存储在栈上的对象只能由当前方法或线程访问，这样就减少了对内存的分配和垃圾回收的工作量，从而提高了程序的性能。<br>
可以通过 -XX:+DoEscapeAnalysis 指定是否进行逃逸分析。</p>
<p>参考：<br>
<a href="http://www.hollischuang.com/archives/2398">http://www.hollischuang.com/archives/2398</a></p>
<h2 id="3-接口和抽象类的共同点和区别">3.接口和抽象类的共同点和区别</h2>
<p>共同点:</p>
<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现的方法</li>
</ul>
<p>区别：</p>
<ul>
<li>接口是对类的行为进行约束，实现了某个接口就有了对应的行为，抽象类主要用于代码复用，强调的是所属关系</li>
<li>类只能继承一个类，但可以实现多个接口</li>
<li>接口中的成员变量只能是<code>public static final</code>,抽象类的成员变量默认<code>defalut</code></li>
</ul>
<h2 id="4-解决哈希冲突的办法">4.解决哈希冲突的办法</h2>
<ul>
<li>
<p>开放地址法<br>
开放地址法是指当发生哈希冲突时，继续在哈希表中查找空闲的位置，直到找到一个空闲的位置为止。其中包括线性探测、二次探测等技术。</p>
</li>
<li>
<p>链表法<br>
链表法是指每个哈希值对应一个链表，如果发生哈希冲突，则将新的元素加入到对应位置的链表中。</p>
</li>
<li>
<p>再哈希法<br>
再哈希法是指在第一次哈希之后，如果出现冲突，则再次进行哈希，直到找到合适的位置。</p>
</li>
<li>
<p>建立公共溢出区<br>
建立公共溢出区是指将所有冲突的元素都存储在同一个溢出区，并通过某种方式来确定元素在该区域中的位置。</p>
</li>
</ul>
<h2 id="5-String-StringBulider-，StringBuffer">5.String,StringBulider ，StringBuffer</h2>
<p>先看后两者：<br>
共同点：</p>
<ul>
<li>
<p><code>StringBulider</code>和<code>StringBuffer</code>都继承了<code>AbstractStringBuilder</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line"><span class="type">byte</span>[] value;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>区别：</p>
<ul>
<li>StringBuffer线程安全，StringBulider非线程安全。</li>
</ul>
<p><code>String</code>不可变的真正原因：</p>
<ul>
<li>整个类被final修饰，确保不会被继承，防止被子类修改byte数组。</li>
<li>byte数组的修饰符为<code>private final</code> ，同时没有提供修改的方法。</li>
</ul>
<h2 id="6-Java对象的创建过程">6.Java对象的创建过程</h2>
<ol>
<li>
<p>类加载：<br>
检查能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析、初始化过、如果没有，必须先执行相应的类加载过程</p>
</li>
<li>
<p>在堆中分配内存：</p>
<ul>
<li>划分可用空间：<br>
指针碰撞：Serial,ParNew等带Compact过程的收集器时<br>
空闲列表：CMS基于Mark-Sweep算法的收集器</li>
<li>线程安全：<br>
CAS + 失败重试的方法<br>
TLAB: 每个线程预先分配一小块内存</li>
</ul>
</li>
<li>
<p>将分配的内存初始化为0：</p>
</li>
<li>
<p>设置对象头的必要设置：<br>
GC年代，对象的Hash码等</p>
</li>
<li>
<p>执行init方法：<br>
按程序员意愿初始化</p>
</li>
</ol>
<h2 id="7-红黑树">7.红黑树</h2>
<h2 id="性质">性质</h2>
<ol>
<li>结点是红色或黑色；</li>
<li>根结点是黑色。</li>
<li>叶子结点（也叫外部结点、NULL结点、失败结点）是黑色。</li>
<li>不存在两个相邻的红结点。（即红结点的父结点和子结点都是黑色的）</li>
<li>从任意结点到可达的叶子结点的每个路径包含相同数目的黑色节点。</li>
</ol>
<p>速记：左根右，根叶黑，不红红，黑路同。（源自王道）</p>
<h2 id="插入操作">插入操作</h2>
<ol>
<li>先查找，确定插入位置，原理同二叉查找树，</li>
<li>新结点是根，则是黑色<br>
新结点非根，则是红色</li>
<li>若不满足要求，则进行调整<br>
黑叔：旋转 + 染色<br>
LL型：右单旋，父换爷，染色<br>
RR型：左单旋，父换爷，染色<br>
LR型： 左右双旋，儿换爷，染色<br>
RL型：右，左双旋，儿换爷，染色<br>
红叔：染色 + 变新<br>
叔父爷染色，爷变为新结点</li>
</ol>
<h2 id="8-线程和进程的区别？">8.线程和进程的区别？</h2>
<p>（1）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。</p>
<p>（2）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。<br>
注意：TLB,MMU将虚拟地址转换成物理地址，虚拟地址和物理地址的映射存储在页表中，根据时间局部性和空间局部性，专门设置了TLB将经常使用的映射存储在TLB中。</p>
<h2 id="9-死锁的解决办法">9. 死锁的解决办法</h2>
<p>破坏四个必要条件：互斥、占有等待、不可抢占、循环等待</p>
<ul>
<li>占有等待条件，死锁预防：<br>
进程开始前，必须一次性获得所有资源，否则不许执行</li>
<li>不可抢占，</li>
<li>循环等待：<br>
将资源编号，只能申请序号更大的资源</li>
</ul>
<p>银行家算法，分配举证，最大需求矩阵，需求矩阵。</p>
]]></content>
      <categories>
        <category>question</category>
      </categories>
  </entry>
  <entry>
    <title>redis概览</title>
    <url>/2023/05/18/redis/RedisLearning-1/</url>
    <content><![CDATA[<p>从整体上概览Redis的功能。</p>
<span id="more"></span>
<h2 id="数据结构与应用">数据结构与应用</h2>
<p>Redis中的5种基本数据类型：<br>
字符串、散列、列表、集合、有序集合<br>
4种特殊数据结构:<br>
位图、地理坐标、HyperLogLog、流</p>
<h3 id="应用">应用</h3>
<ol>
<li>实现分布式锁：
<ul>
<li>获取锁：set lock “locked” NX</li>
<li>释放锁：DEL lock</li>
<li>判断锁是否已经获取：判断SET操作是否成功</li>
<li>判断锁是否已经释放：判断DEL操作的返回值是否为1<br>
（DEL:接受一个或多个数据库键作为参数，尝试删除这些键以及与之相关联的值，并返回被删除键的数量作为结果）</li>
</ul>
</li>
</ol>
<h2 id="数据库命令">数据库命令</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>切换到指定数据库</td>
<td></td>
</tr>
<tr>
<td>KEYS</td>
<td>返回与匹配符相匹配的键</td>
<td></td>
</tr>
<tr>
<td>SCAN</td>
<td>以渐进方式迭代数据库中的键</td>
<td></td>
</tr>
<tr>
<td>RANDOMKEY</td>
<td>随机返回一个键</td>
<td></td>
</tr>
<tr>
<td>SORT</td>
<td>对键的值进行排序</td>
<td></td>
</tr>
<tr>
<td>EXISTS</td>
<td>检查给定键是否存在</td>
<td></td>
</tr>
<tr>
<td>DBSIZE</td>
<td>获取数据中包含键值对的数量</td>
<td></td>
</tr>
<tr>
<td>TYPE</td>
<td>查看键的类型</td>
<td></td>
</tr>
<tr>
<td>RENAME</td>
<td>修改键名</td>
<td></td>
</tr>
<tr>
<td>RENAMENX</td>
<td>只有当新键名未被占用的情况下修改键名</td>
<td></td>
</tr>
<tr>
<td>MOVE</td>
<td>将给定的键移动到另一个数据库</td>
<td></td>
</tr>
<tr>
<td>DEL</td>
<td>移除指定的键，同步方式</td>
<td></td>
</tr>
<tr>
<td>UNLINK</td>
<td>移除指定的键，异步方式</td>
<td></td>
</tr>
<tr>
<td>FLUSHDB</td>
<td>清空当前数据库</td>
<td></td>
</tr>
<tr>
<td>FLUSHALL</td>
<td>清空所有数据库</td>
<td></td>
</tr>
<tr>
<td>SWAPDB</td>
<td>互换数据库</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="自动过期">自动过期</h2>
<h3 id="场景">场景</h3>
<ul>
<li>网页缓存</li>
<li>用户会话信息</li>
<li>聚合计算时大量的临时数据</li>
</ul>
<h3 id="相关命令">相关命令</h3>
<ul>
<li>
<p>设置生存时间的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>EXPIRE</td>
<td>设置秒级精度的生存时间</td>
<td></td>
</tr>
<tr>
<td>PEXPIRE</td>
<td>设置毫秒级别的生存时间</td>
<td></td>
</tr>
</tbody>
</table>
<p>或者使用SET命令的EX和PX选项</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> key <span class="keyword">value</span> [EX seconds] [PX milliseconds]</span><br></pre></td></tr></table></figure>
<p>这两个选项更重要的是保证了操作的原子性，使得“为键设置值”和“为键设置生存时间”这两个操作可以一起执行。</p>
</li>
<li>
<p>设置过期时间的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>EXPIREAT</td>
<td>当系统的当前UNIX时间超过命令指定的UNIX时间时，给定的键就会被移除，秒级精度</td>
<td></td>
</tr>
<tr>
<td>PEXPIREAT</td>
<td>毫秒级精度</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>获取键的生存时间的命令<br>
如果给定的键存在，但是没有设置生存时间或者过期时间，这两个命令将返回-1<br>
如果给定的键不存在，这两个命令将返回-2</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>TTL</td>
<td>以秒为单位返回键的生存时间</td>
<td></td>
</tr>
<tr>
<td>PTTL</td>
<td>以毫秒为单位返回键的生存时间</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="流水线和事务">流水线和事务</h2>
<p>流水线的作用是将多个命令打包，然后一并发送至服务器，而事务的作用则是将多个命令打包，然后让服务器一并执行它们。</p>
<h3 id="流水线">流水线</h3>
<p>这个特性允许客户端把任意多条Redis命令请求打包在一起，然后一次性地将它们全部发送给服务器，而服务器则会在流水线包含的所有命令请求都处理完毕之后，一次性地将它们的执行结果全部返回给客户端。</p>
<h3 id="事务">事务</h3>
<ol>
<li>相关命令
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MULTI</td>
<td>开启事务</td>
</tr>
<tr>
<td>EXEC</td>
<td>执行事务</td>
</tr>
<tr>
<td>DISCARD</td>
<td>放弃事务</td>
</tr>
</tbody>
</table>
</li>
<li>事务的安全性<br>
具有ACI特性，当Redis服务器运行在特定的持久化模式下具有D特性</li>
</ol>
<h3 id="乐观锁机制">乐观锁机制</h3>
<ol>
<li>相关命令
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>WATCH</td>
<td>客户端可以通过执行WATCH命令，要求服务器对一个或多个数据库键进行监视，如果在客户端尝试执行事务之前，这些键的值发生了变化，那么服务器将拒绝执行客户端发送的事务，并向它返回一个空值：</td>
</tr>
<tr>
<td>UNWATCH</td>
<td>客户端可以通过执行UNWATCH命令，取消对所有键的监视：</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>使用EXEC命令执行事务和使用DISCARD命令取消事务，同样会导致客户端撤销对所有键的监视，这是因为这两个命令在执行之后都会隐式地调用UNWATCH命令。</p>
<h2 id="Lua脚本（未完成）">Lua脚本（未完成）</h2>
<h2 id="持久化">持久化</h2>
<p>RDB持久化、AOF持久化，RDB-AOF混合持久化</p>
<h3 id="RDB持久化">RDB持久化</h3>
<p>RDB持久化是Redis默认使用的持久化功能，该功能可以创建出一个经过压缩的二进制文件，其中包含了服务器在各个数据库中存储的键值对数据等信息</p>
<ol>
<li>命令
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SAVE</td>
<td>阻塞服务器并创建RDB文件</td>
</tr>
<tr>
<td>BGSAVE</td>
<td>以非阻塞方式创建RDB文件</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>但由于执行BGSAVE命令需要创建子进程，所以父进程占用的内存数量越大，创建子进程这一操作耗费的时间也会越长，因此Redis服务器在执行BGSAVE命令时，仍然可能会由于创建子进程而被短暂地阻塞。<br>
2. RDB文件结构<br>
<img src="../../pic/Snipaste_2023-05-28_14-58-18.png" alt="RDB文件结构"><br>
<img src="../../pic/Snipaste_2023-05-28_15-01-15.png" alt="数据库数据结构"><br>
<img src="../../pic/Snipaste_2023-05-28_15-04-02.png" alt="键值对数据结构"><br>
3. 载入RDB文件过程<br>
(1) 打开RDB文件<br>
(2) 检查文件头<br>
(3) 检查版本号<br>
(4) 读取设备信息<br>
(5) 重建数据库<br>
(6) 重建脚本缓存<br>
(7) 对比校验和<br>
(8) 数据载入完毕<br>
4. 数据丢失问题<br>
系统在停机时将丢失最后一次成功实施持久化之后的所有数据。对于一个只使用RDB持久化的Redis服务器来说，服务器停机时丢失的数据量将取决于最后一次成功执行的RDB持久化操作，以及该操作开始执行的时间<br>
(1)SAVE命令<br>
同步操作，服务器将丢失最后一次成功执行命令之后产生的数据<br>
(2)BGSAVE<br>
服务器在停机时丢失的数据量将取决于最后一次成功执行的BGSAVE命令的开始时间。<br>
5. RDB缺陷<br>
RDB持久化是一种全量持久化操作，它在创建RDB文件时需要存储整个服务器包含的所有数据，并因此消耗大量计算资源和内存资源，所以用户是不太可能通过增大RDB文件的生成频率来保证数据安全的。</p>
<h3 id="AOF持久化">AOF持久化</h3>
<p>增量持久化操作，服务器每次执行完命令后，都会以【协议文本】的方式将被执行的命令追加到AOF文件末尾。</p>
<h4 id="打开AOF功能、设置冲洗频率">打开AOF功能、设置冲洗频率</h4>
<p><code>appendonly &lt;value&gt; 值：yes:开启，no:关闭</code><br>
<code>appendfsync &lt;value&gt; 值：always:每执行一个写命令则进行一次冲洗，everysec：每隔1秒（默认），no:不主动，由操作系统决定</code></p>
<h4 id="AOF重写功能">AOF重写功能</h4>
<p>Redis提供了AOF重写功能，该功能能够生成一个全新的AOF文件，并且文件中只包含恢复当前数据库所需的尽可能少的命令。<br>
如何使用：<br>
(1) 用户可以通过执行<code>BGREWRITEAOF</code>命令显式地触发AOF重写操作，该命令是一个无参数命令.<br>
(2) 选项的方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>-aof-rewrite-min-size &lt;value&gt;   <span class="comment">// 设置触发AOF文件重写所需最小文件大小，默认情况64mb</span></span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-percentage &lt;value&gt; <span class="comment">// 出发AOF文件重写所需文件体积增大比例</span></span><br></pre></td></tr></table></figure>
<h4 id="缺点">缺点</h4>
<ul>
<li>AOF文件存储的是协议文本，所以它的体积会比包含相同数据、二进制格式的RDB文件要大得多，并且生成AOF文件所需的时间也会比生成RDB文件所需的时间更长。</li>
<li>因为RDB持久化可以直接通过RDB文件恢复数据库数据，而AOF持久化则需要通过执行AOF文件中保存的命令来恢复数据库（前者是直接的数据恢复操作，而后者则是间接的数据恢复操作），所以RDB持久化的数据恢复速度将比AOF持久化的数据恢复速度快得多，并且数据库体积越大，这两者之间的差距就会越明显。</li>
<li>最后，因为AOF重写使用的BGREWRITEAOF命令与RDB持久化使用的BGSAVE命令一样都需要创建子进程，所以在数据库体积较大的情况下，进行AOF文件重写将占用大量资源，并导致服务器被短暂地阻塞。</li>
</ul>
<h3 id="混合持久化">混合持久化</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">aof-<span class="keyword">use</span>-<span class="title">rdb</span>-<span class="title">preamble</span> &lt;<span class="title">value</span>&gt;    // 默认未开启</span><br></pre></td></tr></table></figure>
<p>换句话说，在开启了RDB-AOF混合持久化功能之后，服务器生成的AOF文件将由两个部分组成，其中位于AOF文件开头的是RDB格式的数据，而跟在RDB数据后面的则是AOF格式的数据，</p>
<h3 id="无持久化">无持久化</h3>
<p><code>save &quot;&quot;</code></p>
<h2 id="发布与订阅">发布与订阅</h2>
<p>Redis中，客户端可以通过订阅特定的频道（channel）来接收发送至该频道的消息，我们把这些订阅频道的客户端称为订阅者（subscriber）</p>
<p>除了订阅频道之外，客户端还可以通过订阅模式（pattern）来接收消息：每当发布者向某个频道发送消息的时候，不仅频道的订阅者会收到消息，与频道匹配的所有模式的订阅者也会收到消息</p>
<h2 id="模块">模块</h2>
<p>Redis的模块功能允许开发者通过Redis开放的一簇API，将Redis用作网络服务和数据存储平台，通过C语言在Redis之上构建任意复杂的、全新的数据结构、功能和应用。</p>
<h2 id="复制">复制</h2>
<p>主从复制（master-slave replication）模式实现的，它允许用户为存储着目标数据库的服务器创建出多个拥有相同数据库副本的服务器，其中存储目标数据库的服务器被称为主服务器（master server），而存储数据库副本的服务器则被称为从服务器（slave server，或者称为replica）</p>
<h3 id="命令">命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>REPLICAOF host port</td>
<td>将接收这个命令的Redis服务器设置为另一个Redis服务器的从服务器</td>
<td></td>
</tr>
<tr>
<td>REPLICAOF no one</td>
<td>让从服务器停止复制，重新变回主服务器</td>
<td></td>
</tr>
<tr>
<td>ROLE</td>
<td>查看服务器担任的角色</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="数据同步">数据同步</h3>
<p>完整同步：</p>
<ol>
<li>主服务器执行BGSAVE命令，生成一个RDB文件，并使用缓冲区存储起在BGSAVE命令之后执行的所有写命令。</li>
<li>当RDB文件创建完毕，主服务器会通过套接字将RDB文件传送给从服务器</li>
<li>从服务器在接收完主服务器传送过来的RDB文件之后，就会载入这个RDB文件，从而获得主服务器在执行BGSAVE命令时的所有数据。</li>
<li>当从服务器完成RDB文件载入操作，并开始上线接受命令请求时，主服务器就会把之前存储在缓存区中的所有写命令发送给从服务器执行</li>
</ol>
<p><code>repl-diskless-sync &lt;yes|no&gt;</code><br>
子进程通过套接字直接将RDB文件写入从服务器。这样主服务器就可以在不创建RDB文件的情况下，完成与从服务器的数据同步。</p>
<p>在线更新：</p>
<ul>
<li>每当主服务器执行完一个写命令之后，它就会将相同的写命令或者具有相同效果的写命令发送给从服务器执行。</li>
</ul>
<p>为了尽可能地降低数据不一致的出现概率:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">min</span>-replicas-<span class="built_in">max</span>-lag &lt;seconds&gt;</span><br><span class="line"><span class="built_in">min</span>-replicas-to-<span class="built_in">write</span> &lt;numbers&gt;</span><br></pre></td></tr></table></figure>
<p>部分同步：<br>
当因故障下线的从服务器重新上线时，主从服务器的数据通常已经不再一致，因此它们必须重新进行同步，让两者的数据库再次回到一致状态。</p>
<ul>
<li>当一个Redis服务器成为另一个服务器的主服务器时，它会把每个被执行的写命令都记录到一个特定长度的先进先出队列中</li>
<li>断线的从服务器尝试重新连接主服务器的时候，主服务器将检查从服务器断线期间，被执行的那些写命令是否仍然保存在队列里面。</li>
<li>如果从服务器缺失的那些写命令已经不存在于队列当中，那么主从服务器将进行一次完整同步。</li>
</ul>
<h2 id="Sentinel">Sentinel</h2>
<p>这种使用正常服务器替换下线服务器以维持系统正常运转的操作，一般被称为故障转移（failover）。<br>
Redis Sentinel可以通过心跳检测的方式监视多个主服务器以及它们属下的所有从服务器，并在某个主服务器下线时自动对其实施故障转移。</p>
<h3 id="配置选项">配置选项</h3>
<p>（1）指定需要哨兵的服务器</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt; </span><br><span class="line"><span class="comment">-- 而quorum参数则用于指定判断这个主服务器下线所需的Sentinel数量。</span></span><br><span class="line">sentinel monitor website_db <span class="number">127.0</span><span class="number">.0</span><span class="number">.16379</span> <span class="number">1</span> </span><br><span class="line"><span class="comment">-- 监视主服务器127.0.0.1 ：6379 并在sentinel中命名为website_db</span></span><br></pre></td></tr></table></figure>
<p>（2）服务器器优先级</p>
<p><code>replica-priority</code><br>
eplica-priority的默认值为100，这个值越小，从服务器的优先级就越高,replica-priority值为0的从服务器永远不会被选为主服务器</p>
<h3 id="新主服务器挑选规则">新主服务器挑选规则</h3>
<p>（1）剔除不符合条件的服务器</p>
<ul>
<li>否决所有已经下线以及长时间没有回复心跳检测的疑似已下线从服务器</li>
<li>否决所有长时间没有与主服务器通信，数据状态过时的从服务器。</li>
<li>否决所有优先级为0的从服务器。</li>
</ul>
<p>（2）挑选服务器</p>
<ul>
<li>优先级最高的从服务器获胜。</li>
<li>如果优先级最高的从服务器有两个或以上，那么复制偏移量最大的那个从服务器获* 胜。</li>
<li>如果符合上述两个条件的从服务器有两个或以上，那么选出它们当中运行ID（运行ID是服务器启动时自动生成的随机ID，这条规则可以确保条件完全相同的多个从服务器最终得到一个有序的比较结果）最小的那一个。</li>
</ul>
<h3 id="Sentinel网络">Sentinel网络</h3>
<p>单个sentinel可能出现单点故障，可以使用多个sentinel组件一个分布式Sentinele网络，网络中的节点可以通过互通消息</p>
<ol>
<li>主观下线和客观下线<br>
当Sentinel网络中的其中一个Sentinel认为某个主服务器已经下线时，它会将这个主服务器标记为主观下线（Subjectively Down, SDOWN），然后询问网络中的其他Sentinel，是否也认为该服务器已下线（换句话说，也就是其他Sentinel是否也将这个主服务器标记成了主观下线）。当同意主服务器已下线的Sentinel数量达到sentinel monitor配置选项中quorum参数所指定的数量时，Sentinel就会将相应的主服务器标记为客观下线（objectively down, ODOWN）</li>
</ol>
<h3 id="管理命令">管理命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SENTINEL masters</td>
<td>获取所有被监视主服务器的信息</td>
</tr>
<tr>
<td>SENTINEL master master-name</td>
<td>获取指定服务器的信息</td>
</tr>
<tr>
<td>SENTINEL slaves master-name</td>
<td>获取被监视主服务器的从服务器信息</td>
</tr>
<tr>
<td>SENTINEL sentinels maseter-name</td>
<td>获取监视同一服务器的其他所有sentinel信息</td>
</tr>
<tr>
<td>SENTINEL get-master-addr-by-name master-name</td>
<td>获取给定主服务器的IP地址和端口号</td>
</tr>
<tr>
<td>SENTINEL reset pattern</td>
<td>重置主服务器状态,SENTINEL reset：重置主服务器状态</td>
</tr>
<tr>
<td>SENTINEL failover</td>
<td>强制执行故障转移</td>
</tr>
<tr>
<td>SENTINEL ckquorum</td>
<td>检查可用Sentinel的数量</td>
</tr>
<tr>
<td>SENTINEL flushconfig</td>
<td>强制写入配置文件</td>
</tr>
</tbody>
</table>
<h3 id="在线配置sentinel（待完成）">在线配置sentinel（待完成）</h3>
<h2 id="集群">集群</h2>
<h3 id="基本特性">基本特性</h3>
<ul>
<li>
<p>Redis集群与单机版Redis服务器一样，也提供了主从复制功能。在Redis集群中，各个Redis服务器被称为节点（node），其中主节点（master node）负责处理客户端发送的读写命令请求，而从节点（replica/slave node）则负责对主节点进行复制。</p>
</li>
<li>
<p>集群中的各个节点将互相监视各自的运行状况，并在某个主节点下线时，通过提升该节点的从节点为新主节点来继续提供服务。</p>
</li>
<li>
<p>Redis集群会将整个数据库空间划分为16384个槽（slot）来实现数据分片（sharding），而集群中的各个主节点则会分别负责处理其中的一部分槽</p>
</li>
</ul>
<h3 id="搭建集群">搭建集群</h3>
<p>一种是使用源码附带的集群自动搭建程序，另一种则是使用配置文件手动搭建集群，</p>
<h4 id="自动搭建程序">自动搭建程序</h4>
<p>创建6个节点</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">$ ./<span class="built_in">create</span>-cluster start</span><br><span class="line">Starting <span class="number">30001</span></span><br><span class="line">Starting <span class="number">30002</span></span><br><span class="line">Starting <span class="number">30003</span></span><br><span class="line">Starting <span class="number">30004</span></span><br><span class="line">Starting <span class="number">30005</span></span><br><span class="line">Starting <span class="number">30006</span></span><br></pre></td></tr></table></figure>
<p>把上述6个节点组合成一个集群</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">$ ./<span class="built_in">create</span>-cluster <span class="built_in">create</span></span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on <span class="number">6</span> nodes...</span><br><span class="line">Master[<span class="number">0</span>] -&gt; Slots <span class="number">0</span><span class="number">-5460</span></span><br><span class="line">Master[<span class="number">1</span>] -&gt; Slots <span class="number">5461</span><span class="number">-10922</span></span><br><span class="line">Master[<span class="number">2</span>] -&gt; Slots <span class="number">10923</span><span class="number">-16383</span></span><br><span class="line">Adding replica <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30004</span> to <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30001</span></span><br><span class="line">Adding replica <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30005</span> to <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30002</span></span><br><span class="line">Adding replica <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30006</span> to <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30003</span></span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span><br><span class="line">[WARNING] Some slaves are <span class="keyword">in</span> the same host as their master</span><br><span class="line">M: <span class="number">9e2</span>ee45f2a78b0d5ab65cbc0c97d40262b47159f <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30001</span></span><br><span class="line">    slots:[<span class="number">0</span><span class="number">-5460</span>] (<span class="number">5461</span> slots) master</span><br><span class="line">M: b2c7a5ca5fa6de72ac2842a2196ab2f4a5c82a6a <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30002</span></span><br><span class="line">    slots:[<span class="number">5461</span><span class="number">-10922</span>] (<span class="number">5462</span> slots) master</span><br><span class="line">M: a80b64eedcd15329bc0dc7b71652ecddccf6afe8127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30003</span></span><br><span class="line">    slots:[<span class="number">10923</span><span class="number">-16383</span>] (<span class="number">5461</span> slots) master</span><br><span class="line">S: ab0b79f233efa0afa467d9ef1700fe5b24154992127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30004</span></span><br><span class="line">    replicates a80b64eedcd15329bc0dc7b71652ecddccf6afe8</span><br><span class="line">S: f584b888fcc0e7648bd838cb3b0e2d1915ac0ad7127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30005</span></span><br><span class="line">    replicates <span class="number">9e2</span>ee45f2a78b0d5ab65cbc0c97d40262b47159f</span><br><span class="line">S: <span class="number">262</span>acdf22f4adb6a20b8116982f2940890693d0b <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30006</span></span><br><span class="line">    replicates b2c7a5ca5fa6de72ac2842a2196ab2f4a5c82a6a</span><br><span class="line">Can I set the above configuration? (<span class="built_in">type</span> <span class="string">&#x27;yes&#x27;</span> to accept):</span><br></pre></td></tr></table></figure>
<p>我们需要向redis-cli提供c（cluster，集群）参数以指示客户端进入集群模式，并通过h（host，主机地址）参数或p（port，端口号）参数指定集群中的某个节点作为入口：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--连接本机端口30001上的集群节点，并向它发送PING命令</span></span><br><span class="line">$ redis-cli -c -p <span class="number">30001</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">30001</span>&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>
<p>如果接收到命令请求的节点并非负责处理命令所指键的节点，那么客户端将根据节点提示的转向信息再次向正确的节点发送命令请求，Redis集群把这个动作称为“转向”（redirect）</p>
<p>关闭集群</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">$ ./<span class="built_in">create</span>-cluster stop</span><br><span class="line">Stopping <span class="number">30001</span></span><br><span class="line">Stopping <span class="number">30002</span></span><br><span class="line">Stopping <span class="number">30003</span></span><br><span class="line">Stopping <span class="number">30004</span></span><br><span class="line">Stopping <span class="number">30005</span></span><br><span class="line">Stopping <span class="number">30006</span></span><br><span class="line"></span><br><span class="line">$ ./<span class="built_in">create</span>-cluster clean</span><br></pre></td></tr></table></figure>
<h4 id="手动搭建集群-待完成">手动搭建集群(待完成)</h4>
<h3 id="集群相关命令">集群相关命令</h3>
<p>（1） 集群管理工具</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">redis-cli <span class="comment">--cluster help</span></span><br><span class="line">Cluster Manager Commands:</span><br><span class="line">  <span class="built_in">create</span>         host1:port1 ... hostN:portN</span><br><span class="line">                 <span class="comment">--cluster-replicas &lt;arg&gt;</span></span><br><span class="line">  check          &lt;host:port&gt; <span class="keyword">or</span> &lt;host&gt; &lt;port&gt; - separated by either colon <span class="keyword">or</span> space</span><br><span class="line">                 <span class="comment">--cluster-search-multiple-owners</span></span><br><span class="line">  info           &lt;host:port&gt; <span class="keyword">or</span> &lt;host&gt; &lt;port&gt; - separated by either colon <span class="keyword">or</span> space</span><br><span class="line">  fix            &lt;host:port&gt; <span class="keyword">or</span> &lt;host&gt; &lt;port&gt; - separated by either colon <span class="keyword">or</span> space</span><br><span class="line">                 <span class="comment">--cluster-search-multiple-owners</span></span><br><span class="line">                 <span class="comment">--cluster-fix-with-unreachable-masters</span></span><br><span class="line">  reshard        &lt;host:port&gt; <span class="keyword">or</span> &lt;host&gt; &lt;port&gt; - separated by either colon <span class="keyword">or</span> space</span><br><span class="line">                 <span class="comment">--cluster-from &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-to &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-slots &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-yes</span></span><br><span class="line">                 <span class="comment">--cluster-timeout &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-pipeline &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-replace</span></span><br><span class="line">  rebalance      &lt;host:port&gt; <span class="keyword">or</span> &lt;host&gt; &lt;port&gt; - separated by either colon <span class="keyword">or</span> space</span><br><span class="line">                 <span class="comment">--cluster-weight &lt;node1=w1...nodeN=wN&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-use-empty-masters</span></span><br><span class="line">                 <span class="comment">--cluster-timeout &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-simulate</span></span><br><span class="line">                 <span class="comment">--cluster-pipeline &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-threshold &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-replace</span></span><br><span class="line">  add-node       new_host:new_port existing_host:existing_port</span><br><span class="line">                 <span class="comment">--cluster-slave</span></span><br><span class="line">                 <span class="comment">--cluster-master-id &lt;arg&gt;</span></span><br><span class="line">  del-node       host:port node_id</span><br><span class="line">  call           host:port command <span class="built_in">arg</span> <span class="built_in">arg</span> .. <span class="built_in">arg</span></span><br><span class="line">                 <span class="comment">--cluster-only-masters</span></span><br><span class="line">                 <span class="comment">--cluster-only-replicas</span></span><br><span class="line">  set-timeout    host:port milliseconds</span><br><span class="line">  import         host:port</span><br><span class="line">                 <span class="comment">--cluster-from &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-from-user &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-from-pass &lt;arg&gt;</span></span><br><span class="line">                 <span class="comment">--cluster-from-askpass</span></span><br><span class="line">                 <span class="comment">--cluster-copy</span></span><br><span class="line">                 <span class="comment">--cluster-replace</span></span><br><span class="line">  backup         host:port backup_directory</span><br><span class="line">  help</span><br></pre></td></tr></table></figure>
<p>（2）集群管理命令<br>
如</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">CLUSTER MEET ip port <span class="comment">-- 将节点添加到集群</span></span><br><span class="line">CLUSTER NODES   <span class="comment">-- 查看集群内所有节点的相关信息</span></span><br><span class="line">CLUSTER MYID    <span class="comment">-- 查看当前节点的运行ID</span></span><br><span class="line">CLUSTER INFO    <span class="comment">-- 查看与集群以及当前节点有关的状态信息：</span></span><br><span class="line">CLUSTER FORGET node-id <span class="comment">-- 从集群中移除节点</span></span><br><span class="line">CLUSTER REPLICATE master-id <span class="comment">--将执行该命令的节点变成给定主节点的从节点：</span></span><br><span class="line">CLUSTER REPLICAS node-id    <span class="comment">-- 返回该节点属下的所有节点</span></span><br><span class="line">CLUSTER FAILOVER [FORCE|TAKEOVER]        <span class="comment">-- 强制执行故障转移</span></span><br><span class="line"><span class="comment">-- FORCE选项时，从节点将在不尝试与主节点进行握手的情况下，直接实施故障转移。这种做法可以让用户在主节点已经下线的情况下立即开始故障转移。但如果用户给定了TAKEOVER选项，那么从节点将在不询问集群中其他节点意见的情况下，直接对主节点实施故障转移。</span></span><br><span class="line">CLUSTER RESET [SOFT|HARD]  <span class="comment">-- 重置该节点，以便在集群中复用该节点：</span></span><br></pre></td></tr></table></figure>
<p>（3）槽管理命令<br>
如</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">CLUSTER SLOTS  <span class="comment">-- 各个槽与集群节点之间的关联信息</span></span><br><span class="line">CLUSTER ADDSLOTS slot [slot ...]    <span class="comment">-- 把槽指派给节点</span></span><br><span class="line">CLUSTER DELSLOTS slot [slot ...]    <span class="comment">-- 撤销对节点的槽指派</span></span><br><span class="line">CLUSTER FLUSHSLOTS          <span class="comment">-- 撤销对该节点的所有槽指派</span></span><br><span class="line">CLUSTER KEYSLOT key         <span class="comment">-- 看键所属的槽</span></span><br><span class="line">CLUSTER COUNTKEYSINSLOT slot    <span class="comment">-- 用户可以查看给定槽包含的键数量</span></span><br><span class="line">CLUSTER GETKEYSINSLOT slot count <span class="comment">-- 获取指定槽包含的键</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Testing</title>
    <url>/2023/05/16/MIT6.031%20Software%20Construction/Testing/</url>
    <content><![CDATA[<h2 id="Objectives">Objectives</h2>
<p>这是学习完该章节后需要达到的目标：</p>
<ul>
<li>understand the value of testing ,and know the process of test-first programming;</li>
<li>be able to jude a test suite for correctness,thoroughness,and size;</li>
<li>be able to design a test suite for a method by partitioning its input space and choosing good test cases;</li>
<li>be able to judge a test suite by measuring its code coverage;</li>
<li>understand and know when to use black box vs. glass box testing, unit tests vs. integration tests, and automated regression testing.</li>
</ul>
<span id="more"></span>
<h2 id="Validation">Validation</h2>
<p>Validation includes:</p>
<ul>
<li>Formal reasoning about a program, usually called verification.<br>
指的是程序正确性的逻辑推理，</li>
<li>Code review.</li>
<li>Testing.</li>
</ul>
<h2 id="Test-first-programming">Test-first programming</h2>
<p>some terms:</p>
<ul>
<li>
<p>A module is a part of a software system that can be designed, implemented, tested, and reasoned about separately from the rest of the system.<br>
此处指的是Java方法，或者在将来探讨更大的模块，如有多种交互方法的类。</p>
</li>
<li>
<p>specification (or spec) describes the behavior of a module</p>
</li>
</ul>
<p>对一个方法来说，spec给出了参数的类型以及对它们的额外要求，同时给出了返回值的类型和输入值之间的关系。在Java代码中spec包括方法签名以及描述其功能的注释。</p>
<ul>
<li>
<p>A module has an implementation that provides its behavior, and clients that use the module.<br>
对于一个方法来说，implementation是方法的方法体，client指调用该方法的函数的代码。同时一个模块的spec对impletation和client两者进行了限制。</p>
</li>
<li>
<p>A test case is a particular choice of inputs, along with the expected output behavior required by the specification.</p>
</li>
<li>
<p>A test suite is a set of test cases for a module.</p>
</li>
</ul>
<p>the development of a single function proceeds in this order:</p>
<ol>
<li>Spec: Write a specification for the function.</li>
<li>Test: Write tests that exercise the specification.</li>
<li>Implement: Write the implementation.</li>
</ol>
<h2 id="Systematic-testing">Systematic testing</h2>
<p>But as a test suite designer, you want to make it fail.</p>
<p>Systematic testing means that we are choosing test cases in a principled way, with the goal of designing a test suite with three desirable properties:</p>
<ul>
<li>
<p>Correct. A correct test suite is a legal client of the specification, and it accepts all legal implementations of the spec without complaint. This gives us the freedom to change how the module is implemented internally without necessarily having to change the test suite.</p>
</li>
<li>
<p>Thorough. A thorough test suite finds actual bugs in the implementation, caused by mistakes that programmers are likely to make.</p>
</li>
<li>
<p>Small. A small test suite, with few test cases, is faster to write in the first place, and easier to update if the specification evolves. Small test suites are also faster to run. You will be able to run your tests more frequently if your test suites are small and fast.</p>
</li>
</ul>
<h2 id="Choosing-test-cases-by-partitioning">Choosing test cases by partitioning</h2>
<h2 id="参考">参考</h2>
<p><a href="http://web.mit.edu/6.031/www/sp21/classes/03-testing/">http://web.mit.edu/6.031/www/sp21/classes/03-testing/</a></p>
]]></content>
      <categories>
        <category>MIT6.031 Software Construction</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-工厂</title>
    <url>/2023/05/25/design%20pattern/Factory-Design-Pattern/</url>
    <content><![CDATA[<p>程序设计中的工厂类是对对象构造、实例化、初始化的封装，<br>
而工厂方法对工厂构造方法进行接口规范化，以允许子类工厂决定具体制造那类产品的实例。</p>
<span id="more"></span>
<p>场景：空战游戏中，敌机分为坦克、飞机。它们都有一些共同的属性和行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enemy</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Enemy</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法，在地图上绘制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Airplane</span> <span class="keyword">extends</span> <span class="title class_">Enemy</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Airplane</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制飞机于上层图层，出现坐标:&quot;</span>+ x + <span class="string">&quot;,&quot;</span> + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;飞机向玩家发起攻击.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tank</span> <span class="keyword">extends</span> <span class="title class_">Enemy</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tank</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制坦克于下层图层，出现坐标:&quot;</span>+ x + <span class="string">&quot;,&quot;</span> + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;坦克向玩家发起攻击.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单工厂">简单工厂</h2>
<p>简单工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> screenWidth;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleFactory</span><span class="params">(<span class="type">int</span> screenWidth)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.screenWidth = screenWidth;</span><br><span class="line">        <span class="built_in">this</span>.random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Enemy <span class="title function_">create</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> random.nextInt(screenWidth);</span><br><span class="line">        <span class="type">Enemy</span> <span class="variable">enemy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">             <span class="comment">// 这里采用字符串的方式进行判断</span></span><br><span class="line">             <span class="comment">// 采用instanceof 判断的方式</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Airplane&quot;</span>:</span><br><span class="line">                enemy = <span class="keyword">new</span> <span class="title class_">Airplane</span>(x,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Tank&quot;</span>:</span><br><span class="line">                enemy = <span class="keyword">new</span> <span class="title class_">Tank</span>(x,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enemy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>客户端Client:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">void</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;游戏开始&quot;</span>);</span><br><span class="line">        <span class="type">SimpleFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleFactory</span>(<span class="number">100</span>);</span><br><span class="line">        factory.create(<span class="string">&quot;Airplane&quot;</span>).show();</span><br><span class="line">        factory.create(<span class="string">&quot;Tank&quot;</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>将对象的创建交给专门的工厂类负责，实现了对象的创建和对象的使用分离。</li>
</ul>
<p>缺点：</p>
<ul>
<li>工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码</li>
<li>而且当产品类型较多时，简单工厂的 if 判断将会非常多，不容易维护。</li>
</ul>
<h2 id="工厂方法">工厂方法</h2>
<p>将简单工厂的制造方法进行拆分，构建起抽象化、多态化的生产模式<br>
某个具体的类交给对应的工厂进行创建，若不是有一个统一的大工厂创建。<br>
分工-------  &gt;提升效率</p>
<p>Factory接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span>()&#123;</span><br><span class="line">    Enemy <span class="title function_">create</span><span class="params">(<span class="type">int</span> screenWidth)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>飞机工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirplaneFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Enemy <span class="title function_">create</span><span class="params">(<span class="type">int</span> screenWidth)</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Airplane</span>(random.nextInt(screenWidth),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>坦克工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TankFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Enemy <span class="title function_">create</span><span class="params">(<span class="type">int</span> screenWidth)</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tank</span>(random.nextInt(screenWidth),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个工厂有自己的生产策略或者方式，<br>
不同的产品需求都可以找到相应的工厂来满足，<br>
即使没有也可以添加新工厂来解决。</p>
<p>存在的问题：<br>
系统如果为每一个产品都增加一个工厂类，会造成工厂类泛滥。</p>
<h2 id="抽象工厂">抽象工厂</h2>
<p>抽象工厂提供了另外一种思路，将各种产品分类，基于此来规划各种工厂的制造接口，最终确立产品制造的顶级规范，使其与具体产品彻底脱钩。<br>
比如某个汽车生产厂，需要生产轿车，卡车，越野车…等很多种类的车辆，需要在工厂中设置多条生产线，抽象工厂就是完成该功能的。</p>
<p>背景：<br>
某公司需要开发一款星际战争游戏，分为人类文明和野兽文明两种阵营。每种阵营的兵种可以被归纳为初级、中级、高级三种</p>
<p>抽象类工厂接口 <code>AbstractFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">    LowClassUnit <span class="title function_">createLowClass</span><span class="params">()</span>;</span><br><span class="line">    MidClassUnit <span class="title function_">createMidClass</span><span class="params">()</span>;</span><br><span class="line">    HighClassUnit <span class="title function_">createHighClass</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>人类兵工厂 <code>HumanFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HumanFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanFactory</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LowClassUnit <span class="title function_">createLowClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LowClassUnit</span> <span class="variable">unit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Marine</span>(x,y);</span><br><span class="line">        System.out.println(<span class="string">&quot;制造海军陆战队成员成功。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> unit;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MidClassUnit <span class="title function_">createMidClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MidClassUnit</span> <span class="variable">unit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>(x,y);</span><br><span class="line">        System.out.println(<span class="string">&quot;制造变形坦克成功。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> unit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HighClassUnit <span class="title function_">createHighClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HighClassUnit</span> <span class="variable">unit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Battleship</span>(x,y);</span><br><span class="line">        System.out.println(<span class="string">&quot;制造巨型战舰成功。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> unit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外星兵工厂 <code>AlienFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlienFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AlienFactory</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LowClassUnit <span class="title function_">createLowClass</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MidClassUnit <span class="title function_">createMidClass</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HighClassUnit <span class="title function_">createHighClass</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外可以加入一个&quot;制造工厂的工厂&quot;来决定让那个工厂投入运行</p>
]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap source code</title>
    <url>/2023/05/25/collections/HashMap-source-code/</url>
    <content><![CDATA[<p>JDK版本 :<br>
openjdk 17.0.7 2023-04-18 LTS<br>
OpenJDK Runtime Environment Corretto-17.0.7.7.1 (build 17.0.7+7-LTS)<br>
OpenJDK 64-Bit Server VM Corretto-17.0.7.7.1 (build 17.0.7+7-LTS, mixed mode, sharing)</p>
<span id="more"></span>
<h2 id="hash函数">hash函数</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="comment">// ^ 按位异或</span></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; 无符号右移</span></span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="number">0</span> : (h = key.hashCode()) ^ h &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造">构造</h2>
<p>Node数据结构，链表的组成元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash; </span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">// 下一个结点</span></span><br><span class="line">        Node&lt;K, V&gt; next;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的声明和变量的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认初始化容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1073741824</span>;</span><br><span class="line">    <span class="comment">// 默认装载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75F</span>;</span><br><span class="line">    <span class="comment">// 当结点数大于8的时候转红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当结点数小于6的时候转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 转红黑树时，table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存放键值对</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K, V&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 元素的个数，不等于数组长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算threshold的方法，给定一个容量计算其threshold</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> : (n &gt;= <span class="number">1073741824</span> ? <span class="number">1073741824</span> : n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">            <span class="comment">//  1GB = 1073741824 = 1024 * 1024 * 1024 </span></span><br><span class="line">            initialCapacity = <span class="number">1073741824</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 如果loadFactor值合法</span></span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &lt;= <span class="number">0.0F</span>) &amp;&amp; !Float.isNaN(loadFactor)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">            <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不合法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0.75F</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = <span class="number">0.75F</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = <span class="number">0.75F</span>;</span><br><span class="line">    <span class="built_in">this</span>.putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加元素">添加元素</h2>
<h3 id="添加元素的put方法">添加元素的put方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用put方法会调用putVal方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node[] tab;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">// 如果map为空或者map的长度为0时，进行resize扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = <span class="built_in">this</span>.table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (tab = <span class="built_in">this</span>.resize()).length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object p;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">// 如果数组的[hash &amp;n-1]位置没有元素时，直接插入</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = n - <span class="number">1</span> &amp; hash]) == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[i] = <span class="built_in">this</span>.newNode(hash, key, value, (Node)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 有元素，发生了hash冲突</span></span><br><span class="line">            Object e;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">// 如果该key已经存在，并且就是第一个链表结点时，直接覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (((Node)p).hash == hash &amp;&amp; ((k = ((Node)p).key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                e = p;</span><br><span class="line">            &#125; <span class="comment">// 判断是否红黑树结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                e = ((TreeNode)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 在链表插入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = ((Node)p).next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        ((Node)p).next = <span class="built_in">this</span>.newNode(hash, key, value, (Node)<span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果结点数目达到阈值时，转红黑树</span></span><br><span class="line">                            <span class="built_in">this</span>.treeifyBin(tab, hash);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 在链表上已经有该key</span></span><br><span class="line">                    <span class="comment">// 疑问：为什么没有覆盖？答：在后面进行了</span></span><br><span class="line">                    <span class="keyword">if</span> (((Node)e).hash == hash &amp;&amp; ((k = ((Node)e).key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    p = e;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 覆盖新值</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> ((Node)e).value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ((Node)e).value = value;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.afterNodeAccess((Node)e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++<span class="built_in">this</span>.modCount;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="built_in">this</span>.size &gt; <span class="built_in">this</span>.threshold) &#123;</span><br><span class="line">            <span class="built_in">this</span>.resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="转红黑树">转红黑树</h3>
<p>数结点 TreeNode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K, V&gt; parent;</span><br><span class="line">    TreeNode&lt;K, V&gt; left;</span><br><span class="line">    TreeNode&lt;K, V&gt; right;</span><br><span class="line">    TreeNode&lt;K, V&gt; prev; <span class="comment">// 临时指针？，需要在连接后删除</span></span><br><span class="line">    <span class="type">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转红黑树的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K, V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">// 如果数组不空且长度大于64时，转红黑树</span></span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt;= <span class="number">64</span>) &#123;</span><br><span class="line">            <span class="type">int</span> index;</span><br><span class="line">            Node e;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ((e = tab[index = n - <span class="number">1</span> &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; hd = <span class="literal">null</span>;</span><br><span class="line">                TreeNode&lt;K, V&gt; tl = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    TreeNode&lt;K, V&gt; p = <span class="built_in">this</span>.replacementTreeNode(e, (Node)<span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (tl == <span class="literal">null</span>) &#123;</span><br><span class="line">                        hd = p;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        p.prev = tl;</span><br><span class="line">                        tl.next = p;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    tl = p;</span><br><span class="line">                &#125; <span class="keyword">while</span>((e = e.next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    hd.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加元素总结">添加元素总结</h3>
<ol>
<li>程序调用put方法添加元素，put方法会调用putVal方法</li>
<li>调用后有几种情况
<ul>
<li>如果map为空或者map的长度为0时，既不需要插入链表结点也不需要转红黑树，调用resize方法扩容数组</li>
<li>如果hash后得到的位置上没有元素，没有发生hash冲突，直接放在数组的该位置上</li>
<li>发生了冲突，如果链表的头结点的key,hash值与待插入的元素一致，直接覆盖</li>
<li>如果是红黑树结点，调用putTreeVal方法插入红黑树</li>
<li>最后一种情况是遍历链表插入，在插入的过程中，如果发现链表结点数等于8的时候尝试进行转红黑树，treeifyBin方法</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>collections</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-解释器</title>
    <url>/2023/04/01/design%20pattern/InterpreterDesignPattern/</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<blockquote>
<p>解释器模式(Interpreter)会针对某种语言并基于其语法特征创建一系列的表达式类（包括终极表达式与非终极表达式），利用树结构模式将表达式对象组装起来，最终将其翻译成计算机能够识别并执行的语义树。</p>
<p>例如结构型数据库对查询语言SQL的解析，浏览器对HTML语言的解析，以及操作系统Shell对命令的解析。不同的语言有着不同的语法和翻译方式，这都依靠解释器完成.</p>
</blockquote>
<span id="more"></span>
<h3 id="解释器模式中的角色划分">解释器模式中的角色划分</h3>
<hr>
<p><img src="../../pic/2023-04-01-20-07-17.png" alt="角色划分"></p>
<hr>
<p><code>AbstractExpression</code>（抽象表达式）</p>
<blockquote>
<p>定义解释器的标准接口interpret()，所有终极表达式类与非终极表达式类均需实现此接口。对应本章例程中的表达式接口Expression。</p>
</blockquote>
<p><code>AbstractExpression</code>（抽象表达式</p>
<blockquote>
<p>抽象表达式接口的实现类，具有原子性、不可拆分性的表达式。对应本章例程中的鼠标移动表达式Move、鼠标左键按下表达式LeftKeyDown、鼠标左键松开表达式LeftKeyUp、延迟表达式Delay。</p>
</blockquote>
<p><code>TerminalExpression</code>（终极表达式）</p>
<blockquote>
<p>抽象表达式接口的实现类，具有原子性、不可拆分性的表达式。对应本章例程中的鼠标移动表达式Move、鼠标左键按下表达式LeftKeyDown、鼠标左键松开表达式LeftKeyUp、延迟表达式Delay。</p>
</blockquote>
<p><code>NonTerminalExpression</code>（非终极表达式）</p>
<blockquote>
<p>抽象表达式接口的实现类，包含一个或多个表达式接口引用，所以它所包含的子表达式可以是非终极表达式，也可以是终极表达式。对应本章例程中的左键单击表达式LeftKeyClick、循环表达式Repetition、表达式序列Sequence。</p>
</blockquote>
<p><code>Context</code>（上下文）</p>
<blockquote>
<p>需要被解释的语言类，它包含符合解释器语法规则的具体语言。对应本例程中的滑鼠精灵脚本MouseScript。</p>
</blockquote>
<p><code>Client</code>（客户端）</p>
<blockquote>
<p>根据语言的语法结构生成对应的表达式语法树，然后调用根表达式的解释方法得到结果</p>
</blockquote>
<h2 id="示例">示例</h2>
<p>一段驱动鼠标的脚本，根据该脚本建模。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BEGIN                   // 脚本开始</span><br><span class="line">MOVE 500,600;           // 鼠标指针移动到坐标（500，600）</span><br><span class="line">    BEGIN LOOP 5        // 开始循环5次</span><br><span class="line">        LEFT_CLICK;     // 循环体内单机左键</span><br><span class="line">        DELAY 1;        // 每次延迟1秒</span><br><span class="line">    END;                // 循环体结束</span><br><span class="line">RIGHT DOWN;             // 按下右键</span><br><span class="line">DELAY 7200;             // 延迟2小时</span><br><span class="line">END;                    // 脚本结束</span><br></pre></td></tr></table></figure>
<h3 id="表达式接口">表达式接口</h3>
<p>对所有表达式进行行为抽象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpre</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="终极表达式">终极表达式</h3>
<p>鼠标移动表达式 <code>Expression</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Move</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y )</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;移动鼠标：【&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y +<span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标左键按下表达式 <code>LeftKeyDown</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftKeyDown</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;按下鼠标: 左键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标左键松开表达式 <code>LeftKeyUp</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftKeyUp</span> <span class="keyword">implements</span> <span class="title class_">Expression</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;松开鼠标：左键&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标右键松开表达式 <code>RightKeyUp</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightKeyUp</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;松开鼠标：右键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标右键按下表达式 <code>RightKeyDown</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightKeyDown</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;按下鼠标: 右键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>延迟表达式 <code>Delay</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Delay</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seconds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Delay</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seconds = seconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSeconds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;系统延迟: &quot;</span>+ seconds + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(seconds * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非终极表达式">非终极表达式</h3>
<p>左键单击表达式 <code>LeftKeyClick</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftKeyClick</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression leftKeyDown;</span><br><span class="line">    <span class="keyword">private</span> Expression leftKeyUp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeftKeyClick</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftKeyDown = <span class="keyword">new</span> <span class="title class_">LeftKeyDown</span>();</span><br><span class="line">        <span class="built_in">this</span>.leftKeyUp = <span class="keyword">new</span> <span class="title class_">LeftKeyUp</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        leftKeyDown.interpret();</span><br><span class="line">        leftKeyUp.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环表达式 <code>Repetition</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Repetition</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopCount;</span><br><span class="line">    <span class="keyword">private</span> Expression loopBodySequence;    <span class="comment">// 循环体内子表达式序列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Repetition</span><span class="params">( Expression loopBodySequence,<span class="type">int</span> loopCount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopCount = loopCount;</span><br><span class="line">        <span class="built_in">this</span>.loopBodySequence = loopBodySequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (loopCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            loopBodySequence.interpret();</span><br><span class="line">            loopCount-- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>表达式序列 <code>Sequence</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sequence</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Expression&gt; expressions;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sequence</span><span class="params">(List&lt;Expression&gt; expressions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.expressions = expressions;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        expressions.forEach(expression -&gt; expression.interpret());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="客户端">客户端</h3>
<p>根据语言的语法结构生成对应的表达式语法树，然后调用根表达式的解释方法得到结果。</p>
<p>客户端 <code>Client</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sequence</span>(Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Move</span>(<span class="number">500</span>,<span class="number">600</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Repetition</span>(<span class="keyword">new</span> <span class="title class_">Sequence</span>(Arrays.asList(<span class="keyword">new</span> <span class="title class_">LeftKeyClick</span>(),<span class="keyword">new</span> <span class="title class_">Delay</span>(<span class="number">1</span>))), <span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RightKeyClick</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Delay</span>(<span class="number">7200</span>)));</span><br><span class="line"></span><br><span class="line">        sequence.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li>刘韬《秒懂设计模式》</li>
</ul>
]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
      <tags>
        <tag>解释器</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Questions-1</title>
    <url>/2023/05/25/someQuestions/Questions-1/</url>
    <content><![CDATA[<h2 id="题目来源">题目来源</h2>
<p>如何判断 Java 工程师的基础知识是否扎实？ - 王争的回答 - 知乎<br>
<a href="https://www.zhihu.com/question/48312588/answer/3034670442">https://www.zhihu.com/question/48312588/answer/3034670442</a></p>
]]></content>
      <categories>
        <category>question</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-原型</title>
    <url>/2023/04/07/design%20pattern/ProtoTypeDesignPattern/</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<blockquote>
<p>原型模式达到以原型实例创建副本实例的目的即可，并不需要知道其他原始类，也就是说，原型模式可以用对象创建对象，而不是用类创建对象，以此达到效率的提升。</p>
</blockquote>
<p>对那些非常复杂的初始化过程的对象或者是需要耗费大量资源的情况，原型模式是更好的选择。</p>
<span id="more"></span>
<h2 id="示例">示例</h2>
<p>我们正准备设计一个空战游戏</p>
<p>设定：<br>
设置游戏为单打即主角飞机只有一架，而敌机有很多架，而且可以在屏幕上垂直下移来撞击主角飞机。</p>
<p><code>EnemyPlane:敌机类</code></p>
<ul>
<li>敌机默认从屏幕顶部飞出，故设定y坐标为0</li>
<li>只给出属性的setter方法表示我们一旦设定好敌机的x轴坐标就不再可能手动修改</li>
<li>通过连续调用fly方法，敌机就可以一直向下飞行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnemyPlane</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnemyPlane</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.y++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Client:客户端类</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;EnemyPlane&gt; enemyPlanes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="type">EnemyPlane</span> <span class="variable">ep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnemyPlane</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">200</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在的问题">存在的问题</h3>
<ol>
<li>在游戏的初始化阶段直接示例500架飞机无疑会占用大量内<br>
存，使得加载速度变慢<br>
解决办法：懒加载，屏幕滚动到一定值的时候才实例对象。单问题依然存在，游戏运行大量实例进行初始化及其浪费CPU性能。</li>
</ol>
<h3 id="使用ProtoType模式">使用ProtoType模式</h3>
<p><code>EnemyPlane:敌机类</code></p>
<ul>
<li>重写Object的clone方法，以便外部能够实现对本类实例的克隆，省略构造过程。</li>
<li>编写了x属性的setter方法，以便能够对克隆出来的敌机实例横坐标进行修改。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnemyPlane</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnemyPlane</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> EnemyPlane <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (EnemyPlane)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EnemyplaneFactory</code>:敌机工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnemyPlaneFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">EnemyPlane</span> <span class="variable">protoType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnemyPlane</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnemyPlane <span class="title function_">getInstance</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">EnemyPlane</span> <span class="variable">clone</span> <span class="operator">=</span> protoType.clone();</span><br><span class="line">        clone.setX(x);</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Client</code>：客户端类</p>
<ul>
<li>每隔10高度，克隆一个敌机</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;EnemyPlane&gt; planes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">screen</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 屏幕滚动的高度</span></span><br><span class="line">      <span class="keyword">while</span>(screen &lt; <span class="number">100</span>)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(screen % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="type">EnemyPlane</span> <span class="variable">instance</span> <span class="operator">=</span> EnemyPlaneFactory.getInstance(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">200</span>));</span><br><span class="line">              planes.add(instance);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (EnemyPlane plane : planes) &#123;</span><br><span class="line">              plane.fly();</span><br><span class="line">              System.out.println(<span class="string">&quot;敌机：&quot;</span>+plane.toString()+<span class="string">&quot;,&quot;</span>+plane.getX()+<span class="string">&quot;,&quot;</span>+plane.getY());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          screen ++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深浅拷贝">深浅拷贝</h2>
<ul>
<li>浅拷贝</li>
</ul>
<blockquote>
<p>所谓浅拷贝是指只复制原始类型的值，比如横坐标x与纵坐标y这种以原始类型int定义的值，它们会被复制到新克隆出的对象中。而引用类型bullet同样会被拷贝，但是请注意这个操作只是拷贝了地址引用（指针），也就是说副本敌机与原型敌机中的子弹是同一颗，因为两个同样的地址实际指向的内存对象是同一个bullet对象。</p>
</blockquote>
<ul>
<li>深拷贝</li>
</ul>
<p>即手动实例化对象并将地址引用赋值给对应属性</p>
<h2 id="克隆的本质">克隆的本质</h2>
<blockquote>
<p>克隆操作时Java虚拟机会进行内存操作，直接拷贝原型对象数据流生成新的副本对象，绝不会拖泥带水地触发一些多余的复杂操作（如类加载、实例化、初始化等），所以其效率远远高于“new”关键字所触发的实例化操作</p>
</blockquote>
<h2 id="参考">参考</h2>
<ol>
<li>刘韬《秒懂设计模式》</li>
</ol>
]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-单例</title>
    <url>/2023/04/01/design%20pattern/SingletonDesignPattern/</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<p>单例即单实例，指在系统(程序)中，某个类只存在一个实例，同时提供集中、统一的访问接口。</p>
<blockquote>
<p>如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。</p>
</blockquote>
<p>例如：<br>
<code>Spring</code>中<code>bean</code>的定义可以被定义为两种：<code>prototype(原型)</code>,<code>singleton(单例)</code><br>
<code>线程池（threadpool）</code>, <code>缓存（cache）</code>等比较适合设计为单例模式。</p>
<span id="more"></span>
<h2 id="单例模式的实现">单例模式的实现</h2>
<ol>
<li>饿汉模式</li>
<li>懒汉模式</li>
<li>双重校验锁</li>
<li>静态内部类</li>
<li>枚举</li>
</ol>
<h3 id="饿汉模式">饿汉模式</h3>
<p>类加载时，创建实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Sun</span> <span class="variable">sun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sun</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sun</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sun <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>私有化的构造方法保证了该类的实例化工作完全属于内部事务，任何外部内无法干预。</li>
<li><code>private</code>该实例的私有性，不可见性，不可访问性。</li>
<li><code>static</code> 确保了实例的<code>静态性</code>，当类加载时候进行初始化。</li>
<li><code>final</code> 确保该实例是个常量，一旦被赋值就不能再修改</li>
<li><code>getInstance()</code>提供对外获取该实例的接口。</li>
</ol>
<p>缺点：该实例如果没用到也会被创建，浪费了内存。<br>
因此该模式适合单例占用内存比较小，创建成功后立即被使用的情况。如果单例占用内存较大，使用懒汉模式进行延迟加载就更合适。</p>
<h3 id="懒汉模式">懒汉模式</h3>
<p>第一次使用时，创建实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Sun sun;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sun</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sun1 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sun == <span class="literal">null</span>)&#123;</span><br><span class="line">            sun = <span class="keyword">new</span> <span class="title class_">Sun</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有当某线程第一次调用<code>getInstance()</code>方法时，该实例才创建实例。</p>
<h4 id="存在的问题">存在的问题</h4>
<p>在多线程的情况下，很多线程并发的进行 <code>if (sun == null)</code>判断，程序就会多次实例化太阳，对sun进行多次赋值。<br>
解决办法：<code>getInstance</code> 添加 <code>synchronized</code>关键字。</p>
<p>改造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Sun sun;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sun</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> Sun <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sun == <span class="literal">null</span>)&#123;</span><br><span class="line">            sun = <span class="keyword">new</span> <span class="title class_">Sun</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方法依然存在问题:<br>
<code>synchronized</code>修饰的同步方法比一般方法要慢很多，如果多次调用<code>getInstance()</code>，累积的性能损耗就比较大了。</p>
<h3 id="双重校验锁">双重校验锁</h3>
<p>这种模式是懒汉模式的变种，利用<b>双验锁</b>解决<code>synchronized</code>修饰同步方法开销过大的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Sun sun;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sun</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sun <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sun == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Sun.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (sun == <span class="literal">null</span>)&#123;</span><br><span class="line">                    sun = <span class="keyword">new</span> <span class="title class_">Sun</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>volatile</code> 禁止指令重排</li>
<li>第一次校验，即第一个 <code>if (sun == null)</code>判断，程序执行的过程中，大部分线程并不需要进入到同步代码块，保证了线程并发的高效性</li>
<li>第二次校验，防止二次创建实例。在某情况下，线程A和线程B都通过了第一次校验，实例会被重新赋值。</li>
</ol>
<h3 id="静态内部类">静态内部类</h3>
<p>利用了类加载机制来保证只创建一个instance实例</p>
<blockquote>
<p>它是在内部类里面去创建对象实例。这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Sun</span> <span class="variable">sun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sun</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sun</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sun <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举">枚举</h3>
<p>既可以避免多线程同步问题；还可以防止通过反射和反序列化来重新创建新的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li>刘韬《秒懂设计模式》</li>
<li><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">https://www.runoob.com/design-pattern/singleton-pattern.html</a></li>
<li><a href="https://blog.csdn.net/goodlixueyong/article/details/51935526">https://blog.csdn.net/goodlixueyong/article/details/51935526</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1497592">https://cloud.tencent.com/developer/article/1497592</a></li>
</ul>
]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
  </entry>
</search>
