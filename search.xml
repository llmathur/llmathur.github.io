<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java多线程学习（一）</title>
    <url>/2023/05/26/Java-multithread/Java-multithread-0/</url>
    <content><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程的原理"><a href="#进程的原理" class="headerlink" title="进程的原理"></a>进程的原理</h3><p>进程指程序的一次执行过程，具有动态性，有状态间的相互切换。<br>一般来说一个进程包括以下内容：</p>
<ul>
<li><p>程序段：进程的程序指令在内存中的位置，包含所有需要执行的指令集合</p>
</li>
<li><p>数据段：存放进程所需要的各种数据</p>
</li>
<li><p>PCB:包含程序的描述信息和和控制信息，是进程存在的唯一标识</p>
</li>
</ul>
<p>其中PCB中包含以下信息：</p>
<ul>
<li>进程描述信息</li>
<li>进程调度信息</li>
<li>进程的资源信息</li>
<li>进程上下文</li>
</ul>
<h3 id="线程的原理"><a href="#线程的原理" class="headerlink" title="线程的原理"></a>线程的原理</h3><p>线程指“进程代码段”的一次顺序执行过程。是CPU调度的基本单位，一个进程可以有多个线程。<br>各个线程之间共享进行的内存空间、系统资源。<br>一个线程有以下三个部分：</p>
<ul>
<li>线程描述信息</li>
<li>程序计数器</li>
<li>栈内存</li>
</ul>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul>
<li>进程包含线程</li>
<li>分配资源：进程，执行单位：线程</li>
<li>进程之间相互独立，线程之间不一定相互独立，共享资源：堆，方法区等</li>
<li>切换速度不同，进程切换TLB,页表等都可能替换。<span id="more"></span></li>
</ul>
<h2 id="线程的相关类和接口-未完成"><a href="#线程的相关类和接口-未完成" class="headerlink" title="线程的相关类和接口(未完成)"></a>线程的相关类和接口(未完成)</h2><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        NEW,</span><br><span class="line">        RUNNABLE,</span><br><span class="line">        BLOCKED,</span><br><span class="line">        WAITING,</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Runnable-接口"><a href="#Runnable-接口" class="headerlink" title="Runnable 接口"></a>Runnable 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 无返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数式接口：只有一个抽象方法的接口，<code>@FunctionalInterface</code>表明这一点</li>
</ul>
<h3 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a><code>Thread</code> 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String name;   <span class="comment">// 线程名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> priority;   <span class="comment">// 优先级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> daemon; <span class="comment">// 是否为守护线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> interrupted;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> stillborn;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> eetop;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">private</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader contextClassLoader;</span><br><span class="line">    <span class="keyword">private</span> AccessControlContext inheritedAccessControlContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> threadInitNumber;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals;</span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> stackSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> tid;     <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> threadSeqNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> threadStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Object parkBlocker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object blockerLock;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StackTraceElement[] EMPTY_STACK_TRACE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br><span class="line">    <span class="meta">@Contended(&quot;tlr&quot;)</span></span><br><span class="line">    <span class="type">long</span> threadLocalRandomSeed;</span><br><span class="line">    <span class="meta">@Contended(&quot;tlr&quot;)</span></span><br><span class="line">    <span class="type">int</span> threadLocalRandomProbe;</span><br><span class="line">    <span class="meta">@Contended(&quot;tlr&quot;)</span></span><br><span class="line">    <span class="type">int</span> threadLocalRandomSecondarySeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>疑问：</p>
<ol>
<li>线程名为什么使用<code>volatile</code>关键字？</li>
</ol>
<h3 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a><code>Callable</code> 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现线程的四种方法"><a href="#实现线程的四种方法" class="headerlink" title="实现线程的四种方法"></a>实现线程的四种方法</h2><h3 id="继承Thred类"><a href="#继承Thred类" class="headerlink" title="继承Thred类"></a>继承Thred类</h3><ol>
<li>继承Thread类，创建一个新的线程类</li>
<li>重写run()方法，将需要执行的业务代码编写咋run()方法中</li>
<li>调用start()方法</li>
</ol>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>Thread类的run()方法，可以看到，该方法实际调用了target的run方法</p>
<p><code>private Runnable target;</code> 而targert实际上正是Runnable类型的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.target != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义一个新类实现Runnable接口</li>
<li>实现Runnable接口中的run()抽象方法</li>
<li>通过Thread类创建线程对象,将Runnable实例作为实际参数传递给Thread类的构造器，该构造器将Runnable实例赋值给自己的target执行目标属性</li>
<li>调用start()方法</li>
</ol>
<h4 id="两种优雅的方式"><a href="#两种优雅的方式" class="headerlink" title="两种优雅的方式"></a>两种优雅的方式</h4><ol>
<li>匿名内部类</li>
<li>Lambda表达式</li>
</ol>
<h3 id="使用Callable和FutureTask创建线程"><a href="#使用Callable和FutureTask创建线程" class="headerlink" title="使用Callable和FutureTask创建线程"></a>使用Callable和FutureTask创建线程</h3><p>前两种方式都不能获取异步执行的结果。因为run()方法没有提供返回值</p>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol>
<li>编写一个callable的实现类</li>
<li>重写call方法</li>
<li>利用实现类的对象实例化一个FutureTask对象，构造方法</li>
<li>使用FutureTask对象实例化一个Thread对象，构造方法</li>
<li>调用start方法，start方法会调用FutureTask的run方法，run方法会调用call方法</li>
<li>使用Futuretask的get方法获取结果</li>
</ol>
<h4 id="RunnableFuture-接口"><a href="#RunnableFuture-接口" class="headerlink" title="RunnableFuture 接口"></a>RunnableFuture 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个接口同时继承了Runnable，Future两个接口。<br>第一个接口保证了它能被赋值为Thread的target变量。被Thread执行<br>第二个接口保证了可以获取未来的结果</p>
<h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> var1)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取结果 阻塞性质</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">//设置阻塞时限，获取结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口提供了以下功能</p>
<ul>
<li>能够取消异步中执行的任务</li>
<li>能够判断异步任务是否完成</li>
<li>能够获取任务完成后的执行结果</li>
</ul>
<p>而FutureTask 提供了对该接口的具体实现</p>
<h4 id="FutureTask-类"><a href="#FutureTask-类" class="headerlink" title="FutureTask 类"></a>FutureTask 类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable; <span class="comment">// 线程的并发执行、任务结果的异步获取</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// FutureTask的outcome实例属性用于保存callable成员call()方法的异步执行结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask的run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state == <span class="number">0</span> &amp;&amp; RUNNER.compareAndSet(<span class="built_in">this</span>, (Void)<span class="literal">null</span>, Thread.currentThread())) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">var9</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var9 = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Callable</span> <span class="variable">c</span> <span class="operator">=</span> <span class="built_in">this</span>.callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.state == <span class="number">0</span>) &#123;</span><br><span class="line">                    Object result;</span><br><span class="line">                    <span class="type">boolean</span> ran;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        result = c.call();  <span class="comment">// 调用call方法并获取结果</span></span><br><span class="line">                        ran = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">                        result = <span class="literal">null</span>;</span><br><span class="line">                        ran = <span class="literal">false</span>;</span><br><span class="line">                        <span class="built_in">this</span>.setException(var10);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (ran) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.set(result);   <span class="comment">// 保存结果到outcome</span></span><br><span class="line">                        var9 = <span class="literal">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        var9 = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    var9 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var9 = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (var9) &#123;</span><br><span class="line">                <span class="built_in">this</span>.runner = <span class="literal">null</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="built_in">this</span>.state;</span><br><span class="line">                <span class="keyword">if</span> (s &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.handlePossibleCancellationInterrupt(s);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过线程池创建线程"><a href="#通过线程池创建线程" class="headerlink" title="通过线程池创建线程"></a>通过线程池创建线程</h3><p>Java中提供了一个静态工厂来创建不同的线程池，该静态工厂为<code>Executors</code>工厂类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">// 3表示线程的容量</span></span><br></pre></td></tr></table></figure>

<h4 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重要的是这三个方法</span></span><br><span class="line">    <span class="comment">// 只需要传入对应的的实例即可运行线程</span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; var1)</span>;</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable var1, T var2)</span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable var1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExecutors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个包含三个线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">ReturnRunnable</span>(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReturnRunnable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行后，发现前三个线程几乎是同时执行，等待1s的时间后，再执行剩下的线程</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Java高并发核心编程 卷 2</p>
]]></content>
      <categories>
        <category>Java multithread</category>
      </categories>
  </entry>
  <entry>
    <title>Java多线程学习（一）</title>
    <url>/2023/05/26/Java-multithread/Java-multithread-1/</url>
    <content><![CDATA[<h2 id="线程的核心原理"><a href="#线程的核心原理" class="headerlink" title="线程的核心原理"></a>线程的核心原理</h2><p>JVM甚至将每个Java线程一对一地对应到操作系统的本地线程，彻底将线程调度委托给操作系统。</p>
<h3 id="线程的调度与时间片"><a href="#线程的调度与时间片" class="headerlink" title="线程的调度与时间片"></a>线程的调度与时间片</h3><p>目前主流的线程调度方式：基于CPU时间片方式进行线程调度</p>
<p>线程的调度模式：</p>
<ul>
<li>分时调度模型：系统平均分配CPU的时间片，所有线程轮流占用时间片</li>
<li>抢占式调度：系统按优先级分配时间片，优先级高的先分配，如果所有线程的优先级相同，随机选择一个。</li>
</ul>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>Thread类中定义优先级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> priority;`</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级常量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">// 最低优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 最高优先级</span></span><br></pre></td></tr></table></figure>

<p>与优先级相关的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkAccess();</span><br><span class="line">    <span class="comment">// 检查优先级范围</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &lt;= <span class="number">10</span> &amp;&amp; newPriority &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        <span class="keyword">if</span> ((g = <span class="built_in">this</span>.getThreadGroup()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setPriority0(<span class="built_in">this</span>.priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>Thread类中保存线程状态的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> threadStatus;</span><br></pre></td></tr></table></figure>

<p>Thread类中获取线程状态的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> VM.toThreadState(<span class="built_in">this</span>.threadStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回状态的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.State <span class="title function_">toThreadState</span><span class="params">(<span class="type">int</span> threadStatus)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((threadStatus &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.RUNNABLE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((threadStatus &amp; <span class="number">1024</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.BLOCKED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((threadStatus &amp; <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.WAITING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((threadStatus &amp; <span class="number">32</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.TIMED_WAITING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((threadStatus &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.TERMINATED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (threadStatus &amp; <span class="number">1</span>) == <span class="number">0</span> ? State.NEW : State.RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义线程状态常量的内部枚举类，共有6个枚举常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">       NEW,        <span class="comment">//新建 </span></span><br><span class="line">       RUNNABLE,   <span class="comment">// 可执行，包括操作系统的就绪、运行</span></span><br><span class="line">       BLOCKED,    <span class="comment">// 阻塞</span></span><br><span class="line">       WAITING,    <span class="comment">// 等待</span></span><br><span class="line">       TIMED_WAITING,  <span class="comment">// 限时等待</span></span><br><span class="line">       TERMINATED; <span class="comment">//终止</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">State</span><span class="params">()</span> &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>NEW:<br>  创建成功但是没有调用start()方法启动的Thread线程实例都处于NEW状态</li>
<li>RUNNABLE:<br>  调用了start方法，线程的状态；对应操作系统的就绪和执行两种状态</li>
<li>TERMINATED：<br>  run()方法执行结束后，或者run()方法被异常终止</li>
<li>TIMED_WAITING：<br>  限时等待，可能的情况有以下几种<br>  Thread.sleep(int n) :使得当前线程进入限时等待状态，等待时间为n毫秒<br>  Object.wait():带时限的抢占对象的monitor锁</li>
</ul>
<h2 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h2><h3 id="线程名"><a href="#线程名" class="headerlink" title="线程名"></a>线程名</h3><p>略</p>
<h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><p>线程状态由执行态变为阻塞状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> var0)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数毫秒，第二个参数纳秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt;= <span class="number">0</span> &amp;&amp; nanos &lt;= <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span> &amp;&amp; millis &lt; Long.MAX_VALUE) &#123;</span><br><span class="line">            ++millis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(millis);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h3><p>中断标志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> interrupted; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// currentThread()返回正在执行的线程信息</span></span><br><span class="line">    <span class="comment">// 如果该线程未处于运行状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> != currentThread()) &#123;</span><br><span class="line">        <span class="comment">// 此方法用于检查当前正在执行的线程是否具有修改权限。</span></span><br><span class="line">        <span class="built_in">this</span>.checkAccess();</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>.blockerLock) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> <span class="built_in">this</span>.blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 修改中断标志</span></span><br><span class="line">                <span class="built_in">this</span>.interrupted = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">this</span>.interrupt0();</span><br><span class="line">                b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程处于运行状态</span></span><br><span class="line">    <span class="comment">// 修改中断标志</span></span><br><span class="line">    <span class="built_in">this</span>.interrupted = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="join方法-待完善"><a href="#join方法-待完善" class="headerlink" title="join方法(待完善)"></a>join方法(待完善)</h3><p>线程A需要将线程B的执行流程合并到自己的执行流程中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait(delay);</span><br><span class="line">            &#125; <span class="keyword">while</span>(<span class="built_in">this</span>.isAlive() &amp;&amp; (delay = millis - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; <span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (millis != <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt;= <span class="number">0</span> &amp;&amp; nanos &lt;= <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span> &amp;&amp; millis &lt; Long.MAX_VALUE) &#123;</span><br><span class="line">            ++millis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.join(millis);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="built_in">this</span>.join(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>线程的yield（让步）操作的作用是让目前正在执行的线程放弃当前的执行，让出CPU的执行权限，使得CPU去执行其他的线程。</p>
<p>处于让步状态的JVM层面的线程状态仍然是RUNNABLE状态，但是该线程所对应的操作系统层面的线程从状态上来说会从执行状态变成就绪状态。线程在yield时，线程放弃和重占CPU的时间是不确定的，可能是刚刚放弃CPU，马上又获得CPU执行权限，重新开始执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>注</p>
<ul>
<li>yield仅能使一个线程从运行态转到就绪态，而不是阻塞态</li>
<li>yield不能保证使得当前正在运行的线程迅速切换到就绪状态</li>
<li>即使转换成功，挑选下一个线程时，就绪的线程有可能被选中，也有可能不被选中。</li>
</ul>
<h3 id="线程的daemon操作"><a href="#线程的daemon操作" class="headerlink" title="线程的daemon操作"></a>线程的daemon操作</h3><p>Java中的线程分为两类：守护线程与用户线程。守护线程也称为后台线程，专门指在程序进程运行过程中，在后台提供某种通用服务的线程。比如，每启动一个JVM进程，都会在后台运行一系列的GC（垃圾回收）线程，这些GC线程就是守护线程，提供幕后的垃圾回收服务</p>
<p>实例属性和实例方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> daemon;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置是否为守护线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.daemon = on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程的守护状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isDaemon</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.daemon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程和用户线程的本质区别是：二者与JVM虚拟机进程终止的方向不同。用户线程和JVM进程是主动关系，如果用户线程全部终止，JVM虚拟机进程也随之终止；守护线程和JVM进程是被动关系，如果JVM进程终止，所有的守护线程也随之终止</p>
<p>注：</p>
<ul>
<li>守护线程必须在启动前将其守护状态设置为true，启动之后不能再将用户线程设置为守护线程，否则JVM会抛出一个InterruptedException异常。</li>
<li>守护线程存在被JVM强行终止的风险，所以在守护线程中尽量不去访问系统资源，如文件句柄、数据库连接等。守护线程被强行终止时，可能会引发系统资源操作不负责任的中断，从而导致资源不可逆的损坏</li>
<li>守护线程创建的线程也是守护线程。</li>
</ul>
]]></content>
      <categories>
        <category>Java multithread</category>
      </categories>
  </entry>
  <entry>
    <title>JVM学习（一）</title>
    <url>/2023/05/16/JVM-learning/JVMLearning/</url>
    <content><![CDATA[<p>编译器可以分为：前端编译器、JIT 编译器和AOT编译器。</p>
<span id="more"></span>
<h2 id="源代码到机器码"><a href="#源代码到机器码" class="headerlink" title="源代码到机器码"></a>源代码到机器码</h2><h3 id="前端编译器：源代码到字节码"><a href="#前端编译器：源代码到字节码" class="headerlink" title="前端编译器：源代码到字节码"></a>前端编译器：源代码到字节码</h3><h3 id="JIT-编译器：从字节码到机器码"><a href="#JIT-编译器：从字节码到机器码" class="headerlink" title="JIT 编译器：从字节码到机器码"></a>JIT 编译器：从字节码到机器码</h3><h3 id="AOT-编译器：源代码到机器码"><a href="#AOT-编译器：源代码到机器码" class="headerlink" title="AOT 编译器：源代码到机器码"></a>AOT 编译器：源代码到机器码</h3><h2 id="字节码文件结构"><a href="#字节码文件结构" class="headerlink" title="字节码文件结构"></a>字节码文件结构</h2><h2 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h2><p>当编译器将 Java 源码编译为字节码之后，虚拟机便可以将字节码读取进内存，从而进行解析、运行等整个过程。</p>
<p>JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：<br>加载、验证、准备、解析、初始化、使用、卸载。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。<br>因为Class文件并不要求一定要从Java源代码编译而来，可以从其他地方加载，如网络，甚至包括十六进制编辑器。</p>
<ul>
<li><p>文件格式验证<br>字节流格式，是否以0xcafebabe开头，主次版本号是否在当前虚拟机处理范围内等</p>
</li>
<li><p>元数据验证<br>Java语言规范验证，是否有父类，父类是否继承了不允许的类等</p>
</li>
<li><p>字节码验证</p>
</li>
<li><p>符号引用验证 —- 链接的第三阶段：解析阶段发生</p>
</li>
</ul>
<h2 id="准备（重点）"><a href="#准备（重点）" class="headerlink" title="准备（重点）"></a>准备（重点）</h2><p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。</p>
<ul>
<li>内存分配的对象。<br>Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。</li>
<li>初始化的类型。<br>在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。<br>但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。</p>
<h2 id="初始化（重点）"><a href="#初始化（重点）" class="headerlink" title="初始化（重点）"></a>初始化（重点）</h2><p>在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><h1 id="JVM-垃圾回收机制"><a href="#JVM-垃圾回收机制" class="headerlink" title="JVM 垃圾回收机制"></a>JVM 垃圾回收机制</h1><p>所以很多时候不同的虚拟机有不同的实现方式，下面所说的垃圾回收都是以 HotSpot 虚拟机为例。</p>
<h2 id="判断垃圾方法"><a href="#判断垃圾方法" class="headerlink" title="判断垃圾方法"></a>判断垃圾方法</h2><ol>
<li><p>引用计数法 — 循环引用问题</p>
</li>
<li><p>GC Root Tracing 算法<br>从 GC Root 出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾。GC ROOT通常包括</p>
</li>
</ol>
<ul>
<li>所有当前被加载的 Java 类</li>
<li>Java 类的引用类型静态变量</li>
<li>Java类的运行时常量池里的引用类型常量</li>
<li>JVM的一些静态数据结构里指向GC堆里的对象的引用</li>
<li>等等</li>
</ul>
<h2 id="如何进行垃圾回收"><a href="#如何进行垃圾回收" class="headerlink" title="如何进行垃圾回收"></a>如何进行垃圾回收</h2><p>三种算法：标记清除算法、复制算法、标记压缩算法。</p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>从名字可以看到其分为两个阶段：标记阶段和清除阶段。一种可行的实现方式是，在标记阶段，标记所有由 GC Root 触发的可达对象。此时，所有未被标记的对象就是垃圾对象。之后在清除阶段，清除所有未被标记的对象。标记清除算法最大的问题就是空间碎片问题。如果空间碎片过多，则会导致内存空间的不连续。虽说大对象也可以分配在不连续的空间中，但是效率要低于连续的内存空间。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法的核心思想是将原有的内存空间分为两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收。该算法的缺点是要将内存空间折半，极大地浪费了内存空间。</p>
<h3 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h3><p>标记压缩算法可以说是标记清除算法的优化版，其同样需要经历两个阶段，分别是：标记结算、压缩阶段。在标记阶段，从 GC Root 引用集合触发去标记所有对象。在压缩阶段，其则是将所有存活的对象压缩在内存的一边，之后清理边界外的所有空间。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对比一下这三种算法，可以发现他们都有各自的优点和缺点。</p>
<p>标记清除算法虽然会产生内存碎片，但是不需要移动太多对象，比较适合在存活对象比较多的情况。而复制算法虽然需要将内存空间折半，并且需要移动存活对象，但是其清理后不会有空间碎片，比较适合存活对象比较少的情况。而标记压缩算法，则是标记清除算法的优化版，减少了空间碎片。</p>
<h2 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h2><p>分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代）</p>
<p>分代算法，就是根据 JVM 内存的不同内存区域，采用不同的垃圾回收算法。</p>
<p>例如对于存活对象少的新生代区域，比较适合采用复制算法。这样只需要复制少量对象，便可完成垃圾回收，并且还不会有内存碎片。而对于老年代这种存活对象多的区域，比较适合采用标记压缩算法或标记清除算法，这样不需要移动太多的内存对象。</p>
<h2 id="分区思想"><a href="#分区思想" class="headerlink" title="分区思想"></a>分区思想</h2><p>但 JVM 中其实还有一个分区思想，即将整个堆空间划分成连续的不同小区间。<br>分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代）</p>
<h1 id="JVM垃圾回收器"><a href="#JVM垃圾回收器" class="headerlink" title="JVM垃圾回收器"></a>JVM垃圾回收器</h1><p>四大类别：串行回收器、并行回收器、CMS 回收器、G1 回收器。</p>
<h2 id="串行回收器"><a href="#串行回收器" class="headerlink" title="串行回收器"></a>串行回收器</h2><p>串行回收器是指使用单线程进行垃圾回收的回收器。</p>
<h2 id="并行回收器"><a href="#并行回收器" class="headerlink" title="并行回收器"></a>并行回收器</h2><p>并行回收器在串行回收器的基础上做了改进，其使用多线程进行垃圾回收。</p>
<h2 id="CMS-回收器"><a href="#CMS-回收器" class="headerlink" title="CMS 回收器"></a>CMS 回收器</h2><p>与 ParallelGC 和 ParallelOldGC 不同，CMS 回收器主要关注系统停顿时间。CMS 回收器全称为 Concurrent Mark Sweep，意为标记清除算法，其是一个使用多线程并行回收的垃圾回收器。</p>
<h2 id="G1-回收器"><a href="#G1-回收器" class="headerlink" title="G1 回收器"></a>G1 回收器</h2><p>G1 回收器是 JDK 1.7 中使用的全新垃圾回收器，从长期目标来看，其是为了取代 CMS 回收器。</p>
<p>G1 回收器拥有独特的垃圾回收策略，和之前所有垃圾回收器采用的垃圾回收策略不同。从分代看，G1 依然属于分代垃圾回收器。但它最大的改变是使用了分区算法，从而使得 Eden 区、From 区、Survivor 区和老年代等各块内存不必连续。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/chanshuyi/p/jvm_serial_04_from_source_code_to_machine_code.html">https://www.cnblogs.com/chanshuyi/p/jvm_serial_04_from_source_code_to_machine_code.html</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Testing</title>
    <url>/2023/05/16/MIT6.031%20Software%20Construction/Testing/</url>
    <content><![CDATA[<h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2><p>这是学习完该章节后需要达到的目标：</p>
<ul>
<li>understand the value of testing ,and know the process of test-first programming;</li>
<li>be able to jude a test suite for correctness,thoroughness,and size;</li>
<li>be able to design a test suite for a method by partitioning its input space and choosing good test cases;</li>
<li>be able to judge a test suite by measuring its code coverage; </li>
<li>understand and know when to use black box vs. glass box testing, unit tests vs. integration tests, and automated regression testing.</li>
</ul>
<span id="more"></span>

<h1 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h1><p>Validation includes:</p>
<ul>
<li>Formal reasoning about a program, usually called verification.<br>指的是程序正确性的逻辑推理，</li>
<li>Code review. </li>
<li>Testing.</li>
</ul>
<h2 id="Test-first-programming"><a href="#Test-first-programming" class="headerlink" title="Test-first programming"></a>Test-first programming</h2><p>some terms:</p>
<ul>
<li><p>A module is a part of a software system that can be designed, implemented, tested, and reasoned about separately from the rest of the system.<br>此处指的是Java方法，或者在将来探讨更大的模块，如有多种交互方法的类。</p>
</li>
<li><p>specification (or spec) describes the behavior of a module.<br>对一个方法来说，spec给出了参数的类型以及对它们的额外要求，同时给出了返回值的类型和输入值之间的关系。在Java代码中spec包括方法签名以及描述其功能的注释。</p>
</li>
<li><p>A module has an implementation that provides its behavior, and clients that use the module.<br>对于一个方法来说，implementation是方法的方法体，client指调用该方法的函数的代码。同时一个模块的spec对impletation和client两者进行了限制。</p>
</li>
<li><p>A test case is a particular choice of inputs, along with the<br>expected output behavior required by the specification.</p>
</li>
<li><p>A test suite is a set of test cases for a module.</p>
</li>
</ul>
<p>the development of a single function proceeds in this order:</p>
<ol>
<li>Spec: Write a specification for the function.</li>
<li>Test: Write tests that exercise the specification.</li>
<li>Implement: Write the implementation.</li>
</ol>
<h2 id="Systematic-testing"><a href="#Systematic-testing" class="headerlink" title="Systematic testing"></a>Systematic testing</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://web.mit.edu/6.031/www/sp21/classes/03-testing/">http://web.mit.edu/6.031/www/sp21/classes/03-testing/</a></p>
]]></content>
      <categories>
        <category>MIT6.031 Software Construction</category>
      </categories>
  </entry>
  <entry>
    <title>OAuth 2.0</title>
    <url>/2023/05/09/OAuth-2-0/OAuth-2-0/</url>
    <content><![CDATA[<p>OAuth 的核心就是向第三方应用颁发令牌<br>四种授权方式</p>
<ol>
<li>（授权码）authorization-code</li>
<li>（隐藏式）implicit</li>
<li>（密码式）password</li>
<li>（客户端凭证）client credentials</li>
</ol>
<p>注：任何一种方式，第三方应用都必须到系统备案，以获取客户端ID（client ID）和客户端密钥（client secret）</p>
<span id="more"></span>

<h2 id="第一种方式：授权码"><a href="#第一种方式：授权码" class="headerlink" title="第一种方式：授权码"></a>第一种方式：授权码</h2><p>最常用、最安全，适用于有后端的应用。<br>授权码通过前端发送，令牌存储在后端，而且所有与资源服务器的通信都在后端完成。</p>
<p>授权过程：</p>
<p><img src="/./process.png" alt="流程图" title="流程图"></p>
<p>（1）请求授权码<br>A网站提供一个链接，用户点击后会跳转到B网站，授权用户数据给A网站使用<br>链接示意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">    response_type=code&amp;     <span class="comment">// 表示要求返回授权码</span></span><br><span class="line">    client_id=CLIENT_ID&amp;    <span class="comment">// 让B知道谁在请求</span></span><br><span class="line">    redirect_uri=CALLLBACK_URL&amp; <span class="comment">// B接受或者拒绝请求后的跳转网址</span></span><br><span class="line">    scope=read      <span class="comment">// 要求的授权范围</span></span><br></pre></td></tr></table></figure>

<p>（2）返回授权码<br>用户跳转后，B网站要求用户登录， 然后询问是否给A网站授权。用户同意后，B网站返回<code>redirect_uri</code>参数指定的网址，同时携带一个授权码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback?code=AUTHORIZATION_CODE  // code为授权码</span></span><br></pre></td></tr></table></figure>

<p>（3）请求令牌<br>A网站拿到授权码后，可以在后端向B网站请求令牌</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line"> client_id=CLIENT_ID&amp;   </span><br><span class="line"> client_secret=CLIENT_SECRET&amp;       <span class="comment">// client_id 和client_secret参数确定A的身份</span></span><br><span class="line"> grant_type=authorization_code&amp;     <span class="comment">// 参数值为authorization_code，表示采用的授权方式为授权码</span></span><br><span class="line"> code=AUTHORIZATION_CODE&amp;           <span class="comment">// 上一步拿到的授权码</span></span><br><span class="line"> redirect_uri=CALLBACK_URL          <span class="comment">// 令牌颁发后的回调网址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4）返回令牌<br>B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;ACCESS_TOKEN&quot;</span><span class="punctuation">,</span>    <span class="comment">//令牌</span></span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span><span class="number">2592000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;REFRESH_TOKEN&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span><span class="string">&quot;read&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span><span class="number">100101</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span>...<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="第二种方式：隐藏式"><a href="#第二种方式：隐藏式" class="headerlink" title="第二种方式：隐藏式"></a>第二种方式：隐藏式</h2><ol>
<li>令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</li>
<li>纯前端应用，没有后端。</li>
<li>直接向前端颁发令牌。无授权码中间步骤。<br>（1）第一步，A网站提供链接，用户点击链接跳转B网站，授权用户数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=token&amp;  <span class="comment">//要求直接返回令牌</span></span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure>

<p>（2）第二步，B网站授权成功，跳转到A网站（通过<code>redirect_uri</code>）并以参数的形式返回令牌。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure>

<p>注意：令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p>
<h2 id="第三种方式：密码式"><a href="#第三种方式：密码式" class="headerlink" title="第三种方式：密码式"></a>第三种方式：密码式</h2><p>用户把用户名和密码，直接告诉该应用。<br>该应用就使用你的密码，申请令牌。<br>（1）第一步，A网站要求用户提供用户名和密码，向B网站请求令牌</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure>

<p>（2） 第二步，B 网站验证身份通过后，直接给出令牌。<br>注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p>
<h2 id="第四种方式：凭证式（client-credentials）"><a href="#第四种方式：凭证式（client-credentials）" class="headerlink" title="第四种方式：凭证式（client credentials）"></a>第四种方式：凭证式（client credentials）</h2><p>适用于没有前端的命令行应用，即在命令行下请求令牌。<br>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。<br>（1）第一步，A 应用在命令行向 B 发出请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure>

<p>第二步，B 网站验证通过以后，直接返回令牌。</p>
<h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>令牌的有效期到了，OAuth 2.0 允许用户自动更新令牌<br>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET&amp;</span><br><span class="line">  refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure>

<p>B 网站验证通过以后，就会颁发新的令牌。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p>
]]></content>
      <categories>
        <category>OAuth2.0</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-工厂</title>
    <url>/2023/05/25/design%20pattern/Factory-Design-Pattern/</url>
    <content><![CDATA[<p>程序设计中的工厂类是对对象构造、实例化、初始化的封装，<br>而工厂方法对工厂构造方法进行接口规范化，以允许子类工厂决定具体制造那类产品的实例。</p>
<span id="more"></span>

<p>场景：空战游戏中，敌机分为坦克、飞机。它们都有一些共同的属性和行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enemy</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Enemy</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法，在地图上绘制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Airplane</span> <span class="keyword">extends</span> <span class="title class_">Enemy</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Airplane</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制飞机于上层图层，出现坐标:&quot;</span>+ x + <span class="string">&quot;,&quot;</span> + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;飞机向玩家发起攻击.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tank</span> <span class="keyword">extends</span> <span class="title class_">Enemy</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tank</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制坦克于下层图层，出现坐标:&quot;</span>+ x + <span class="string">&quot;,&quot;</span> + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;坦克向玩家发起攻击.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>简单工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> screenWidth;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleFactory</span><span class="params">(<span class="type">int</span> screenWidth)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.screenWidth = screenWidth;</span><br><span class="line">        <span class="built_in">this</span>.random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Enemy <span class="title function_">create</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> random.nextInt(screenWidth);</span><br><span class="line">        <span class="type">Enemy</span> <span class="variable">enemy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">             <span class="comment">// 这里采用字符串的方式进行判断</span></span><br><span class="line">             <span class="comment">// 采用instanceof 判断的方式</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Airplane&quot;</span>:</span><br><span class="line">                enemy = <span class="keyword">new</span> <span class="title class_">Airplane</span>(x,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Tank&quot;</span>:</span><br><span class="line">                enemy = <span class="keyword">new</span> <span class="title class_">Tank</span>(x,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enemy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>客户端Client:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">void</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;游戏开始&quot;</span>);</span><br><span class="line">        <span class="type">SimpleFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleFactory</span>(<span class="number">100</span>);</span><br><span class="line">        factory.create(<span class="string">&quot;Airplane&quot;</span>).show();</span><br><span class="line">        factory.create(<span class="string">&quot;Tank&quot;</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>将对象的创建交给专门的工厂类负责，实现了对象的创建和对象的使用分离。</li>
</ul>
<p>缺点：</p>
<ul>
<li>工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码</li>
<li>而且当产品类型较多时，简单工厂的 if 判断将会非常多，不容易维护。</li>
</ul>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>将简单工厂的制造方法进行拆分，构建起抽象化、多态化的生产模式<br>某个具体的类交给对应的工厂进行创建，若不是有一个统一的大工厂创建。<br>分工——-  &gt;提升效率</p>
<p>Factory接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span>()&#123;</span><br><span class="line">    Enemy <span class="title function_">create</span><span class="params">(<span class="type">int</span> screenWidth)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>飞机工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirplaneFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Enemy <span class="title function_">create</span><span class="params">(<span class="type">int</span> screenWidth)</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Airplane</span>(random.nextInt(screenWidth),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>坦克工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TankFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Enemy <span class="title function_">create</span><span class="params">(<span class="type">int</span> screenWidth)</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tank</span>(random.nextInt(screenWidth),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个工厂有自己的生产策略或者方式，<br>不同的产品需求都可以找到相应的工厂来满足，<br>即使没有也可以添加新工厂来解决。</p>
<p>存在的问题：<br>系统如果为每一个产品都增加一个工厂类，会造成工厂类泛滥。</p>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>抽象工厂提供了另外一种思路，将各种产品分类，基于此来规划各种工厂的制造接口，最终确立产品制造的顶级规范，使其与具体产品彻底脱钩。<br>比如某个汽车生产厂，需要生产轿车，卡车，越野车…等很多种类的车辆，需要在工厂中设置多条生产线，抽象工厂就是完成该功能的。</p>
<p>背景：<br>    某公司需要开发一款星际战争游戏，分为人类文明和野兽文明两种阵营。每种阵营的兵种可以被归纳为初级、中级、高级三种</p>
<p>抽象类工厂接口 <code>AbstractFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">    LowClassUnit <span class="title function_">createLowClass</span><span class="params">()</span>;</span><br><span class="line">    MidClassUnit <span class="title function_">createMidClass</span><span class="params">()</span>;</span><br><span class="line">    HighClassUnit <span class="title function_">createHighClass</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>人类兵工厂 <code>HumanFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HumanFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanFactory</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LowClassUnit <span class="title function_">createLowClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LowClassUnit</span> <span class="variable">unit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Marine</span>(x,y);</span><br><span class="line">        System.out.println(<span class="string">&quot;制造海军陆战队成员成功。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> unit;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MidClassUnit <span class="title function_">createMidClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MidClassUnit</span> <span class="variable">unit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>(x,y);</span><br><span class="line">        System.out.println(<span class="string">&quot;制造变形坦克成功。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> unit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HighClassUnit <span class="title function_">createHighClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HighClassUnit</span> <span class="variable">unit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Battleship</span>(x,y);</span><br><span class="line">        System.out.println(<span class="string">&quot;制造巨型战舰成功。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> unit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外星兵工厂 <code>AlienFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlienFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AlienFactory</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LowClassUnit <span class="title function_">createLowClass</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MidClassUnit <span class="title function_">createMidClass</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HighClassUnit <span class="title function_">createHighClass</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外可以加入一个”制造工厂的工厂”来决定让那个工厂投入运行</p>
]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-解释器</title>
    <url>/2023/04/01/design%20pattern/InterpreterDesignPattern/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>解释器模式(Interpreter)会针对某种语言并基于其语法特征创建一系列的表达式类（包括终极表达式与非终极表达式），利用树结构模式将表达式对象组装起来，最终将其翻译成计算机能够识别并执行的语义树。</p>
<p>例如结构型数据库对查询语言SQL的解析，浏览器对HTML语言的解析，以及操作系统Shell对命令的解析。不同的语言有着不同的语法和翻译方式，这都依靠解释器完成.</p>
</blockquote>
<span id="more"></span>

<h3 id="解释器模式中的角色划分"><a href="#解释器模式中的角色划分" class="headerlink" title="解释器模式中的角色划分"></a>解释器模式中的角色划分</h3><hr>
<p><img src="/2023-04-01-20-07-17.png" alt="角色划分"></p>
<hr>
<p><code>AbstractExpression</code>（抽象表达式）</p>
<blockquote>
<p>定义解释器的标准接口interpret()，所有终极表达式类与非终极表达式类均需实现此接口。对应本章例程中的表达式接口Expression。</p>
</blockquote>
<p><code>AbstractExpression</code>（抽象表达式</p>
<blockquote>
<p>抽象表达式接口的实现类，具有原子性、不可拆分性的表达式。对应本章例程中的鼠标移动表达式Move、鼠标左键按下表达式LeftKeyDown、鼠标左键松开表达式LeftKeyUp、延迟表达式Delay。</p>
</blockquote>
<p><code>TerminalExpression</code>（终极表达式）</p>
<blockquote>
<p>抽象表达式接口的实现类，具有原子性、不可拆分性的表达式。对应本章例程中的鼠标移动表达式Move、鼠标左键按下表达式LeftKeyDown、鼠标左键松开表达式LeftKeyUp、延迟表达式Delay。</p>
</blockquote>
<p><code>NonTerminalExpression</code>（非终极表达式）</p>
<blockquote>
<p>抽象表达式接口的实现类，包含一个或多个表达式接口引用，所以它所包含的子表达式可以是非终极表达式，也可以是终极表达式。对应本章例程中的左键单击表达式LeftKeyClick、循环表达式Repetition、表达式序列Sequence。</p>
</blockquote>
<p><code>Context</code>（上下文）</p>
<blockquote>
<p>需要被解释的语言类，它包含符合解释器语法规则的具体语言。对应本例程中的滑鼠精灵脚本MouseScript。</p>
</blockquote>
<p><code>Client</code>（客户端）</p>
<blockquote>
<p>根据语言的语法结构生成对应的表达式语法树，然后调用根表达式的解释方法得到结果</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p> 一段驱动鼠标的脚本，根据该脚本建模。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BEGIN                   // 脚本开始</span><br><span class="line">MOVE 500,600;           // 鼠标指针移动到坐标（500，600）</span><br><span class="line">    BEGIN LOOP 5        // 开始循环5次</span><br><span class="line">        LEFT_CLICK;     // 循环体内单机左键</span><br><span class="line">        DELAY 1;        // 每次延迟1秒</span><br><span class="line">    END;                // 循环体结束</span><br><span class="line">RIGHT DOWN;             // 按下右键</span><br><span class="line">DELAY 7200;             // 延迟2小时</span><br><span class="line">END;                    // 脚本结束</span><br></pre></td></tr></table></figure>

<h3 id="表达式接口"><a href="#表达式接口" class="headerlink" title="表达式接口"></a>表达式接口</h3><p>对所有表达式进行行为抽象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpre</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="终极表达式"><a href="#终极表达式" class="headerlink" title="终极表达式"></a>终极表达式</h3><p>鼠标移动表达式 <code>Expression</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Move</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y )</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;移动鼠标：【&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y +<span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鼠标左键按下表达式 <code>LeftKeyDown</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftKeyDown</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;按下鼠标: 左键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鼠标左键松开表达式 <code>LeftKeyUp</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftKeyUp</span> <span class="keyword">implements</span> <span class="title class_">Expression</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;松开鼠标：左键&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鼠标右键松开表达式 <code>RightKeyUp</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightKeyUp</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;松开鼠标：右键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鼠标右键按下表达式 <code>RightKeyDown</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightKeyDown</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;按下鼠标: 右键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟表达式 <code>Delay</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Delay</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seconds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Delay</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seconds = seconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSeconds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;系统延迟: &quot;</span>+ seconds + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(seconds * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非终极表达式"><a href="#非终极表达式" class="headerlink" title="非终极表达式"></a>非终极表达式</h3><p>左键单击表达式 <code>LeftKeyClick</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftKeyClick</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression leftKeyDown;</span><br><span class="line">    <span class="keyword">private</span> Expression leftKeyUp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeftKeyClick</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftKeyDown = <span class="keyword">new</span> <span class="title class_">LeftKeyDown</span>();</span><br><span class="line">        <span class="built_in">this</span>.leftKeyUp = <span class="keyword">new</span> <span class="title class_">LeftKeyUp</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        leftKeyDown.interpret();</span><br><span class="line">        leftKeyUp.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环表达式 <code>Repetition</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Repetition</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopCount;</span><br><span class="line">    <span class="keyword">private</span> Expression loopBodySequence;    <span class="comment">// 循环体内子表达式序列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Repetition</span><span class="params">( Expression loopBodySequence,<span class="type">int</span> loopCount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopCount = loopCount;</span><br><span class="line">        <span class="built_in">this</span>.loopBodySequence = loopBodySequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (loopCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            loopBodySequence.interpret();</span><br><span class="line">            loopCount-- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>表达式序列 <code>Sequence</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sequence</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Expression&gt; expressions;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sequence</span><span class="params">(List&lt;Expression&gt; expressions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.expressions = expressions;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        expressions.forEach(expression -&gt; expression.interpret());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>根据语言的语法结构生成对应的表达式语法树，然后调用根表达式的解释方法得到结果。</p>
<p>客户端 <code>Client</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sequence</span>(Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Move</span>(<span class="number">500</span>,<span class="number">600</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Repetition</span>(<span class="keyword">new</span> <span class="title class_">Sequence</span>(Arrays.asList(<span class="keyword">new</span> <span class="title class_">LeftKeyClick</span>(),<span class="keyword">new</span> <span class="title class_">Delay</span>(<span class="number">1</span>))), <span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RightKeyClick</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Delay</span>(<span class="number">7200</span>)));</span><br><span class="line"></span><br><span class="line">        sequence.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>刘韬《秒懂设计模式》</li>
</ul>
]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
      <tags>
        <tag>解释器</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP学习（一）</title>
    <url>/2023/04/05/TCP-IP/TCPIPLearning/</url>
    <content><![CDATA[<p>目前绝大多数网络都采用TCP&#x2F;IP协议，TCP&#x2F;IP是目前最完整的、被普遍接受的通信协议标准</p>
<span id="more"></span>

<h2 id="第一章-TCP-x2F-IP协议基础"><a href="#第一章-TCP-x2F-IP协议基础" class="headerlink" title="第一章 TCP&#x2F;IP协议基础"></a>第一章 TCP&#x2F;IP协议基础</h2><h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><p>指计算机在网络中实现通信必须遵守的规则和约定，主要是对信息传输的速率、传输代码、代码结构、传输控制步骤、差错控制等做出规定并制定出标准。</p>
<h4 id="协议的组成成分"><a href="#协议的组成成分" class="headerlink" title="协议的组成成分"></a>协议的组成成分</h4><p>语义:规定双方完成通信需要的控制信息及执行的动作<br>语法:规定通信双方交换的数据或控制信息的格式和结构<br>时序:规定通信双方彼此的应答关系，包括速度的匹配和顺序</p>
<h4 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h4><p>顺口溜： “物联网淑慧适用”</p>
<ol>
<li>物理层：原始比特流传输，电子信号传输和硬件接口</li>
<li>链路层：物理寻址，将数据分帧并处理流控制</li>
<li>网络层：通过逻辑寻址建立结点之间的连接，包括路由和中继数据</li>
<li>传输层：常规数据传送</li>
<li>会话层：在节点间建立端连接</li>
<li>表示层：格式化数据，为应用程序提供通用接口</li>
<li>应用层：直接对用户应用程序提供服务</li>
</ol>
<p>其中<br>通信子网：第1层—-第3层<br>网络高层：第5层—-第7层</p>
<h4 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h4><ol>
<li>网络接口层：又称网络访问层（Network Access Layer），包括OSI的物理层和链路层，负责向网络物理介质发送数据包，从网络物理介质接收数据包。TCP&#x2F;IP并没有对物理层和链路层进行定义，它只是支持现有的各种底层网络技术和标准</li>
<li>网络层：网络层又称为互联网层或IP层，负责处理IP数据包的传输、路由选择、流量控制和拥塞控制。<br><code>协议：ARP，RARP; IP; ICMP,IGMP;</code></li>
<li>传输层为两台主机上的应用程序提供端到端的通信。<br><code>协议：TCP ,UDP</code></li>
<li>应用层：这个层次包括OSI的会话层、表示层和应用层，直接为特定的应用提供服务。应用层为用户提供一些常用的应用程序。<br><code>协议：FTP,SMTP,HTTP</code></li>
</ol>
<h2 id="aplication-layer"><a href="#aplication-layer" class="headerlink" title="aplication layer"></a>aplication layer</h2><blockquote>
<p>The application layer provides a servcices to the users;<br>kerwords: logical connection</p>
</blockquote>
<h3 id="Application-Layer-Paradigms"><a href="#Application-Layer-Paradigms" class="headerlink" title="Application-Layer Paradigms"></a>Application-Layer Paradigms</h3><ol>
<li>client-server patadigm</li>
<li>peer-to-peer paradigm</li>
<li>Mixed Paradigm</li>
</ol>
<h4 id="Traditional-Parafigm-Client-Server"><a href="#Traditional-Parafigm-Client-Server" class="headerlink" title="Traditional Parafigm:Client-Server"></a>Traditional Parafigm:Client-Server</h4><blockquote>
<p>In this paradigm,the servivce provider is an application program,called the server process;it run continuously,waiting for another application program,called the client process,to make a connection through the Internet and ask for service.</p>
</blockquote>
<ul>
<li>Existing Problems:</li>
</ul>
<ol>
<li>The concentration of the communication load is on the shoulder of the server.</li>
</ol>
<h4 id="New-Paradigm-Peer-to-Peer"><a href="#New-Paradigm-Peer-to-Peer" class="headerlink" title="New Paradigm : Peer-to-Peer"></a>New Paradigm : Peer-to-Peer</h4><blockquote>
<p>A computer connected to the Internet can provide service at one time and recieve service at another time. A computer can even provide and revice services at the same time</p>
</blockquote>
<p>传统的模式中，需要一个时刻都在运行的服务器以接受随时可能由客户端发送的请求。而p2p模式下，一个电脑可以同时提供和接受服务。</p>
<ul>
<li>when：</li>
</ul>
<ol>
<li>when some computers connected to the Internet have something to share with each other.</li>
</ol>
<ul>
<li>Existing Problems:</li>
</ul>
<ol>
<li>security.</li>
<li>applicability.</li>
</ol>
<ul>
<li>Example:</li>
</ul>
<ol>
<li>BitTorrent</li>
<li>Skype</li>
<li>IPTV</li>
<li>Internet telephony.</li>
</ol>
<h4 id="Mixed-Paradigm"><a href="#Mixed-Paradigm" class="headerlink" title="Mixed Paradigm"></a>Mixed Paradigm</h4><blockquote>
<p>a light-load client-server communication can be used to find the address of the peer that can offer a service.</p>
</blockquote>
<h3 id="Application-Programming-Interface"><a href="#Application-Programming-Interface" class="headerlink" title="Application Programming Interface"></a>Application Programming Interface</h3><blockquote>
<p>An interface in programming is a set of instructions between two entities. In this case one of the entities is the process at the aplication layer and the other is sthe operating system that encapsulates the first four layers of the TCP&#x2F;IP protocol suite.</p>
</blockquote>
<p>常见API:</p>
<ol>
<li>socket interface</li>
<li>Transport Layer Interface</li>
<li>STREAM</li>
</ol>
<h4 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h4><blockquote>
<p>it is not a physical entity like them.it is an abstraction.It is a data structure that is created and used by the aplication program.</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>林成浴 《TCP-IP协议及其应用》</li>
<li>《computer networking a top-down approach》</li>
</ol>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-单例</title>
    <url>/2023/04/01/design%20pattern/SingletonDesignPattern/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单例即单实例，指在系统(程序)中，某个类只存在一个实例，同时提供集中、统一的访问接口。</p>
<blockquote>
<p>如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。</p>
</blockquote>
<p>例如：<br><code>Spring</code>中<code>bean</code>的定义可以被定义为两种：<code>prototype(原型)</code>,<code>singleton(单例)</code><br><code>线程池（threadpool）</code>, <code>缓存（cache）</code>等比较适合设计为单例模式。</p>
<span id="more"></span>

<h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><ol>
<li>饿汉模式</li>
<li>懒汉模式</li>
<li>双重校验锁</li>
<li>静态内部类</li>
<li>枚举</li>
</ol>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>类加载时，创建实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Sun</span> <span class="variable">sun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sun</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sun</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sun <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>私有化的构造方法保证了该类的实例化工作完全属于内部事务，任何外部内无法干预。</li>
<li><code>private</code>该实例的私有性，不可见性，不可访问性。</li>
<li><code>static</code> 确保了实例的<code>静态性</code>，当类加载时候进行初始化。</li>
<li><code>final</code> 确保该实例是个常量，一旦被赋值就不能再修改</li>
<li><code>getInstance()</code>提供对外获取该实例的接口。</li>
</ol>
<p>缺点：该实例如果没用到也会被创建，浪费了内存。<br>因此该模式适合单例占用内存比较小，创建成功后立即被使用的情况。如果单例占用内存较大，使用懒汉模式进行延迟加载就更合适。</p>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>第一次使用时，创建实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Sun sun;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sun</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sun1 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sun == <span class="literal">null</span>)&#123;</span><br><span class="line">            sun = <span class="keyword">new</span> <span class="title class_">Sun</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当某线程第一次调用<code>getInstance()</code>方法时，该实例才创建实例。</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>在多线程的情况下，很多线程并发的进行 <code>if (sun == null)</code>判断，程序就会多次实例化太阳，对sun进行多次赋值。<br>解决办法：<code>getInstance</code> 添加 <code>synchronized</code>关键字。</p>
<p>改造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Sun sun;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sun</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> Sun <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sun == <span class="literal">null</span>)&#123;</span><br><span class="line">            sun = <span class="keyword">new</span> <span class="title class_">Sun</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方法依然存在问题:<br><code>synchronized</code>修饰的同步方法比一般方法要慢很多，如果多次调用<code>getInstance()</code>，累积的性能损耗就比较大了。</p>
<h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3><p>这种模式是懒汉模式的变种，利用<b>双验锁</b>解决<code>synchronized</code>修饰同步方法开销过大的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Sun sun;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sun</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sun <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sun == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Sun.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (sun == <span class="literal">null</span>)&#123;</span><br><span class="line">                    sun = <span class="keyword">new</span> <span class="title class_">Sun</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>volatile</code> 禁止指令重排</li>
<li>第一次校验，即第一个 <code>if (sun == null)</code>判断，程序执行的过程中，大部分线程并不需要进入到同步代码块，保证了线程并发的高效性</li>
<li>第二次校验，防止二次创建实例。在某情况下，线程A和线程B都通过了第一次校验，实例会被重新赋值。</li>
</ol>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>利用了类加载机制来保证只创建一个instance实例</p>
<blockquote>
<p>它是在内部类里面去创建对象实例。这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Sun</span> <span class="variable">sun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sun</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sun</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sun <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>既可以避免多线程同步问题；还可以防止通过反射和反序列化来重新创建新的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>刘韬《秒懂设计模式》</li>
<li><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">https://www.runoob.com/design-pattern/singleton-pattern.html</a></li>
<li><a href="https://blog.csdn.net/goodlixueyong/article/details/51935526">https://blog.csdn.net/goodlixueyong/article/details/51935526</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1497592">https://cloud.tencent.com/developer/article/1497592</a></li>
</ul>
]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
  </entry>
  <entry>
    <title>ArrayList源码分析</title>
    <url>/2023/05/24/collections/ArrayList-source-code/</url>
    <content><![CDATA[<p>JDK版本 :<br>    openjdk 17.0.7 2023-04-18 LTS<br>    OpenJDK Runtime Environment Corretto-17.0.7.7.1 (build 17.0.7+7-LTS)<br>    OpenJDK 64-Bit Server VM Corretto-17.0.7.7.1 (build 17.0.7+7-LTS, mixed mode, sharing)</p>
<span id="more"></span>

<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// List默认大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];    <span class="comment">// 当给定元素数目（集合，容量）&lt;=0的时使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];    <span class="comment">// 无参构造的时候使用</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// 存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;   <span class="comment">// 存放元素的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-扩容机制分析"><a href="#1-扩容机制分析" class="headerlink" title="1. 扩容机制分析"></a>1. 扩容机制分析</h2><h3 id="添加一个元素有3个add方法"><a href="#添加一个元素有3个add方法" class="headerlink" title="添加一个元素有3个add方法"></a>添加一个元素有3个add方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length) &#123;</span><br><span class="line">        <span class="comment">// 如果s(list的长度)等于数组的长度时，即存储空间已满</span></span><br><span class="line">        <span class="comment">// 进行扩容</span></span><br><span class="line">        elementData = <span class="built_in">this</span>.grow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    <span class="built_in">this</span>.size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ++<span class="built_in">this</span>.modCount;</span><br><span class="line">    <span class="built_in">this</span>.add(e, <span class="built_in">this</span>.elementData, <span class="built_in">this</span>.size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查下标是否合法</span></span><br><span class="line">    <span class="built_in">this</span>.rangeCheckForAdd(index);</span><br><span class="line">    ++<span class="built_in">this</span>.modCount;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看起来很复杂，功能也是判断数组长度和元素个数是否相等</span></span><br><span class="line">    <span class="comment">// 如果相等则进行扩容</span></span><br><span class="line">    <span class="comment">// 疑问: 为什么以这样的方式判断是否已满，而不是直接</span></span><br><span class="line">    <span class="comment">// this.size === this.elementDate.length的方式判断</span></span><br><span class="line">    <span class="keyword">if</span> ((s = <span class="built_in">this</span>.size) == (elementData = <span class="built_in">this</span>.elementData).length) &#123;</span><br><span class="line">        elementData = <span class="built_in">this</span>.grow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将elementDate 中以index为起始位置的内容拷贝到elementDate以index +1 的位置，拷贝长度为 s-index</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="built_in">this</span>.size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow()方法"></a>grow()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">// 原来的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> <span class="built_in">this</span>.elementData.length;</span><br><span class="line">    <span class="comment">// 如果容量&lt;=0且，该list没有添加任何元素时候</span></span><br><span class="line">    <span class="comment">// 扩容，最小的容量为10，超过10的时候为minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &lt;= <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(<span class="number">10</span>, minCapacity)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是第一次添加元素</span></span><br><span class="line">        <span class="comment">// 确定新的容量，在添加一个元素的add方法中，扩容为原来的1.5倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新数组并复制元素，并返回新数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elementData = Arrays.copyOf(<span class="built_in">this</span>.elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.grow(<span class="built_in">this</span>.size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth);</span><br><span class="line">     <span class="comment">// list的大容量为int的最大值</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= <span class="number">2147483639</span> ? prefLength : hugeLength(oldLength, minGrowth);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加一堆元素"><a href="#添加一堆元素" class="headerlink" title="添加一堆元素"></a>添加一堆元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        ++<span class="built_in">this</span>.modCount;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] elementData;</span><br><span class="line">            <span class="type">int</span> s;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (numNew &gt; (elementData = <span class="built_in">this</span>.elementData).length - (s = <span class="built_in">this</span>.size)) &#123;</span><br><span class="line">                <span class="comment">// 剩余的容量不足，扩容，有可能非1.5倍</span></span><br><span class="line">                elementData = <span class="built_in">this</span>.grow(s + numNew);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">            <span class="built_in">this</span>.size = s + numNew;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rangeCheckForAdd(index);</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        ++<span class="built_in">this</span>.modCount;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] elementData;</span><br><span class="line">            <span class="type">int</span> s;</span><br><span class="line">            <span class="keyword">if</span> (numNew &gt; (elementData = <span class="built_in">this</span>.elementData).length - (s = <span class="built_in">this</span>.size)) &#123;</span><br><span class="line">                elementData = <span class="built_in">this</span>.grow(s + numNew);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> s - index;</span><br><span class="line">            <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">            <span class="built_in">this</span>.size = s + numNew;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>空List添加第一个元素s时，扩容到长度为10</li>
<li>非空且需要扩容的时候有两种情况<ol>
<li>添加一个元素：<br> 长度为原来的1.5倍</li>
<li>添加一堆元素：<br> 长度最小为原来的1.5倍</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>collections</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-原型</title>
    <url>/2023/04/07/design%20pattern/ProtoTypeDesignPattern/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>原型模式达到以原型实例创建副本实例的目的即可，并不需要知道其他原始类，也就是说，原型模式可以用对象创建对象，而不是用类创建对象，以此达到效率的提升。</p>
</blockquote>
<p>对那些非常复杂的初始化过程的对象或者是需要耗费大量资源的情况，原型模式是更好的选择。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们正准备设计一个空战游戏</p>
<p>设定：<br>设置游戏为单打即主角飞机只有一架，而敌机有很多架，而且可以在屏幕上垂直下移来撞击主角飞机。</p>
<p><code>EnemyPlane:敌机类</code></p>
<ul>
<li>敌机默认从屏幕顶部飞出，故设定y坐标为0</li>
<li>只给出属性的setter方法表示我们一旦设定好敌机的x轴坐标就不再可能手动修改</li>
<li>通过连续调用fly方法，敌机就可以一直向下飞行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnemyPlane</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnemyPlane</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.y++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Client:客户端类</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;EnemyPlane&gt; enemyPlanes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="type">EnemyPlane</span> <span class="variable">ep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnemyPlane</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">200</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol>
<li>在游戏的初始化阶段直接示例500架飞机无疑会占用大量内<br>存，使得加载速度变慢<br>解决办法：懒加载，屏幕滚动到一定值的时候才实例对象。单问题依然存在，游戏运行大量实例进行初始化及其浪费CPU性能。</li>
</ol>
<h3 id="使用ProtoType模式"><a href="#使用ProtoType模式" class="headerlink" title="使用ProtoType模式"></a>使用ProtoType模式</h3><p><code>EnemyPlane:敌机类</code></p>
<ul>
<li>重写Object的clone方法，以便外部能够实现对本类实例的克隆，省略构造过程。</li>
<li>编写了x属性的setter方法，以便能够对克隆出来的敌机实例横坐标进行修改。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnemyPlane</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnemyPlane</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> EnemyPlane <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (EnemyPlane)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EnemyplaneFactory</code>:敌机工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnemyPlaneFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">EnemyPlane</span> <span class="variable">protoType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnemyPlane</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnemyPlane <span class="title function_">getInstance</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">EnemyPlane</span> <span class="variable">clone</span> <span class="operator">=</span> protoType.clone();</span><br><span class="line">        clone.setX(x);</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Client</code>：客户端类</p>
<ul>
<li>每隔10高度，克隆一个敌机</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;EnemyPlane&gt; planes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">screen</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 屏幕滚动的高度</span></span><br><span class="line">      <span class="keyword">while</span>(screen &lt; <span class="number">100</span>)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(screen % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="type">EnemyPlane</span> <span class="variable">instance</span> <span class="operator">=</span> EnemyPlaneFactory.getInstance(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">200</span>));</span><br><span class="line">              planes.add(instance);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (EnemyPlane plane : planes) &#123;</span><br><span class="line">              plane.fly();</span><br><span class="line">              System.out.println(<span class="string">&quot;敌机：&quot;</span>+plane.toString()+<span class="string">&quot;,&quot;</span>+plane.getX()+<span class="string">&quot;,&quot;</span>+plane.getY());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          screen ++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><ul>
<li>浅拷贝</li>
</ul>
<blockquote>
<p>所谓浅拷贝是指只复制原始类型的值，比如横坐标x与纵坐标y这种以原始类型int定义的值，它们会被复制到新克隆出的对象中。而引用类型bullet同样会被拷贝，但是请注意这个操作只是拷贝了地址引用（指针），也就是说副本敌机与原型敌机中的子弹是同一颗，因为两个同样的地址实际指向的内存对象是同一个bullet对象。</p>
</blockquote>
<ul>
<li>深拷贝</li>
</ul>
<p>即手动实例化对象并将地址引用赋值给对应属性</p>
<h2 id="克隆的本质"><a href="#克隆的本质" class="headerlink" title="克隆的本质"></a>克隆的本质</h2><blockquote>
<p>克隆操作时Java虚拟机会进行内存操作，直接拷贝原型对象数据流生成新的副本对象，绝不会拖泥带水地触发一些多余的复杂操作（如类加载、实例化、初始化等），所以其效率远远高于“new”关键字所触发的实例化操作</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>刘韬《秒懂设计模式》</li>
</ol>
]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
  </entry>
  <entry>
    <title>redis概览</title>
    <url>/2023/05/18/redis/RedisLearning-0/</url>
    <content><![CDATA[<p>从整体上概览Redis的功能。</p>
<span id="more"></span>

<h2 id="数据结构与应用"><a href="#数据结构与应用" class="headerlink" title="数据结构与应用"></a>数据结构与应用</h2><p>Redis中的5种基本数据类型：<br>    字符串、散列、列表、集合、有序集合<br>4种特殊数据结构:<br>    位图、地理坐标、HyperLogLog、流</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>实现分布式锁：<ul>
<li>获取锁：set lock “locked” NX</li>
<li>释放锁：DEL lock</li>
<li>判断锁是否已经获取：判断SET操作是否成功</li>
<li>判断锁是否已经释放：判断DEL操作的返回值是否为1<br>（DEL:接受一个或多个数据库键作为参数，尝试删除这些键以及与之相关联的值，并返回被删除键的数量作为结果）</li>
</ul>
</li>
</ol>
<h2 id="数据库命令"><a href="#数据库命令" class="headerlink" title="数据库命令"></a>数据库命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>切换到指定数据库</td>
<td></td>
</tr>
<tr>
<td>KEYS</td>
<td>返回与匹配符相匹配的键</td>
<td></td>
</tr>
<tr>
<td>SCAN</td>
<td>以渐进方式迭代数据库中的键</td>
<td></td>
</tr>
<tr>
<td>RANDOMKEY</td>
<td>随机返回一个键</td>
<td></td>
</tr>
<tr>
<td>SORT</td>
<td>对键的值进行排序</td>
<td></td>
</tr>
<tr>
<td>EXISTS</td>
<td>检查给定键是否存在</td>
<td></td>
</tr>
<tr>
<td>DBSIZE</td>
<td>获取数据中包含键值对的数量</td>
<td></td>
</tr>
<tr>
<td>TYPE</td>
<td>查看键的类型</td>
<td></td>
</tr>
<tr>
<td>RENAME</td>
<td>修改键名</td>
<td></td>
</tr>
<tr>
<td>RENAMENX</td>
<td>只有当新键名未被占用的情况下修改键名</td>
<td></td>
</tr>
<tr>
<td>MOVE</td>
<td>将给定的键移动到另一个数据库</td>
<td></td>
</tr>
<tr>
<td>DEL</td>
<td>移除指定的键，同步方式</td>
<td></td>
</tr>
<tr>
<td>UNLINK</td>
<td>移除指定的键，异步方式</td>
<td></td>
</tr>
<tr>
<td>FLUSHDB</td>
<td>清空当前数据库</td>
<td></td>
</tr>
<tr>
<td>FLUSHALL</td>
<td>清空所有数据库</td>
<td></td>
</tr>
<tr>
<td>SWAPDB</td>
<td>互换数据库</td>
<td></td>
</tr>
</tbody></table>
<h2 id="自动过期"><a href="#自动过期" class="headerlink" title="自动过期"></a>自动过期</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>网页缓存</li>
<li>用户会话信息</li>
<li>聚合计算时大量的临时数据</li>
</ul>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul>
<li><p>设置生存时间的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>EXPIRE</td>
<td>设置秒级精度的生存时间</td>
<td></td>
</tr>
<tr>
<td>PEXPIRE</td>
<td>设置毫秒级别的生存时间</td>
<td></td>
</tr>
</tbody></table>
<p>  或者使用SET命令的EX和PX选项</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> key <span class="keyword">value</span> [EX seconds] [PX milliseconds]</span><br></pre></td></tr></table></figure>

<p>  这两个选项更重要的是保证了操作的原子性，使得“为键设置值”和“为键设置生存时间”这两个操作可以一起执行。</p>
</li>
<li><p>设置过期时间的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>EXPIREAT</td>
<td>当系统的当前UNIX时间超过命令指定的UNIX时间时，给定的键就会被移除，秒级精度</td>
<td></td>
</tr>
<tr>
<td>PEXPIREAT</td>
<td>毫秒级精度</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>获取键的生存时间的命令<br>  如果给定的键存在，但是没有设置生存时间或者过期时间，这两个命令将返回-1<br>  如果给定的键不存在，这两个命令将返回-2</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>TTL</td>
<td>以秒为单位返回键的生存时间</td>
<td></td>
</tr>
<tr>
<td>PTTL</td>
<td>以毫秒为单位返回键的生存时间</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="流水线和事务"><a href="#流水线和事务" class="headerlink" title="流水线和事务"></a>流水线和事务</h2><h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>RDB持久化、AOF持久化，RDB-AOF混合持久化</p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>全面持久化操作，</p>
<h4 id="载入RDB文件过程"><a href="#载入RDB文件过程" class="headerlink" title="载入RDB文件过程"></a>载入RDB文件过程</h4><ol>
<li>打开RDB文件</li>
<li>检查文件头</li>
<li>检查版本号</li>
<li>读取设备信息</li>
<li>重建数据库</li>
<li>重建脚本缓存</li>
<li>对比校验和</li>
<li>数据载入完毕</li>
</ol>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>增量持久化操作，服务器每次执行完命令后，都会以【协议文本】的方式将被执行的命令追加到AOF文件末尾。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><p>体积大</p>
</li>
<li><p>数据恢复速度慢</p>
</li>
</ol>
<h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap source code</title>
    <url>/2023/05/25/collections/HashMap-source-code/</url>
    <content><![CDATA[<p>JDK版本 :<br>    openjdk 17.0.7 2023-04-18 LTS<br>    OpenJDK Runtime Environment Corretto-17.0.7.7.1 (build 17.0.7+7-LTS)<br>    OpenJDK 64-Bit Server VM Corretto-17.0.7.7.1 (build 17.0.7+7-LTS, mixed mode, sharing)</p>
<span id="more"></span>

<h2 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="comment">// ^ 按位异或</span></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt; 无符号右移</span></span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="number">0</span> : (h = key.hashCode()) ^ h &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>Node数据结构，链表的组成元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash; </span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">// 下一个结点</span></span><br><span class="line">        Node&lt;K, V&gt; next;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的声明和变量的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认初始化容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1073741824</span>;</span><br><span class="line">    <span class="comment">// 默认装载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75F</span>;</span><br><span class="line">    <span class="comment">// 当结点数大于8的时候转红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当结点数小于6的时候转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 转红黑树时，table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存放键值对</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K, V&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 元素的个数，不等于数组长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算threshold的方法，给定一个容量计算其threshold</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> : (n &gt;= <span class="number">1073741824</span> ? <span class="number">1073741824</span> : n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">            <span class="comment">//  1GB = 1073741824 = 1024 * 1024 * 1024 </span></span><br><span class="line">            initialCapacity = <span class="number">1073741824</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 如果loadFactor值合法</span></span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &lt;= <span class="number">0.0F</span>) &amp;&amp; !Float.isNaN(loadFactor)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">            <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不合法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0.75F</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = <span class="number">0.75F</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = <span class="number">0.75F</span>;</span><br><span class="line">    <span class="built_in">this</span>.putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><h3 id="添加元素的put方法"><a href="#添加元素的put方法" class="headerlink" title="添加元素的put方法"></a>添加元素的put方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用put方法会调用putVal方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node[] tab;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">// 如果map为空或者map的长度为0时，进行resize扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = <span class="built_in">this</span>.table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (tab = <span class="built_in">this</span>.resize()).length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object p;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">// 如果数组的[hash &amp;n-1]位置没有元素时，直接插入</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = n - <span class="number">1</span> &amp; hash]) == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[i] = <span class="built_in">this</span>.newNode(hash, key, value, (Node)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 有元素，发生了hash冲突</span></span><br><span class="line">            Object e;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">// 如果该key已经存在，并且就是第一个链表结点时，直接覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (((Node)p).hash == hash &amp;&amp; ((k = ((Node)p).key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                e = p;</span><br><span class="line">            &#125; <span class="comment">// 判断是否红黑树结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                e = ((TreeNode)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 在链表插入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = ((Node)p).next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        ((Node)p).next = <span class="built_in">this</span>.newNode(hash, key, value, (Node)<span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果结点数目达到阈值时，转红黑树</span></span><br><span class="line">                            <span class="built_in">this</span>.treeifyBin(tab, hash);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 在链表上已经有该key</span></span><br><span class="line">                    <span class="comment">// 疑问：为什么没有覆盖？答：在后面进行了</span></span><br><span class="line">                    <span class="keyword">if</span> (((Node)e).hash == hash &amp;&amp; ((k = ((Node)e).key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    p = e;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 覆盖新值</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> ((Node)e).value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ((Node)e).value = value;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.afterNodeAccess((Node)e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++<span class="built_in">this</span>.modCount;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="built_in">this</span>.size &gt; <span class="built_in">this</span>.threshold) &#123;</span><br><span class="line">            <span class="built_in">this</span>.resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="转红黑树"><a href="#转红黑树" class="headerlink" title="转红黑树"></a>转红黑树</h3><p>数结点 TreeNode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K, V&gt; parent;</span><br><span class="line">    TreeNode&lt;K, V&gt; left;</span><br><span class="line">    TreeNode&lt;K, V&gt; right;</span><br><span class="line">    TreeNode&lt;K, V&gt; prev; <span class="comment">// 临时指针？，需要在连接后删除</span></span><br><span class="line">    <span class="type">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转红黑树的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K, V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">// 如果数组不空且长度大于64时，转红黑树</span></span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt;= <span class="number">64</span>) &#123;</span><br><span class="line">            <span class="type">int</span> index;</span><br><span class="line">            Node e;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ((e = tab[index = n - <span class="number">1</span> &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; hd = <span class="literal">null</span>;</span><br><span class="line">                TreeNode&lt;K, V&gt; tl = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    TreeNode&lt;K, V&gt; p = <span class="built_in">this</span>.replacementTreeNode(e, (Node)<span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (tl == <span class="literal">null</span>) &#123;</span><br><span class="line">                        hd = p;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        p.prev = tl;</span><br><span class="line">                        tl.next = p;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    tl = p;</span><br><span class="line">                &#125; <span class="keyword">while</span>((e = e.next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    hd.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加元素总结"><a href="#添加元素总结" class="headerlink" title="添加元素总结"></a>添加元素总结</h3><ol>
<li>程序调用put方法添加元素，put方法会调用putVal方法</li>
<li>调用后有几种情况<ul>
<li>如果map为空或者map的长度为0时，既不需要插入链表结点也不需要转红黑树，调用resize方法扩容数组</li>
<li>如果hash后得到的位置上没有元素，没有发生hash冲突，直接放在数组的该位置上</li>
<li>发生了冲突，如果链表的头结点的key,hash值与待插入的元素一致，直接覆盖</li>
<li>如果是红黑树结点，调用putTreeVal方法插入红黑树</li>
<li>最后一种情况是遍历链表插入，在插入的过程中，如果发现链表结点数等于8的时候尝试进行转红黑树，treeifyBin方法</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>collections</category>
      </categories>
  </entry>
  <entry>
    <title>Questions-1</title>
    <url>/2023/05/25/someQuestions/Questions-1/</url>
    <content><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>如何判断 Java 工程师的基础知识是否扎实？ - 王争的回答 - 知乎<br><a href="https://www.zhihu.com/question/48312588/answer/3034670442">https://www.zhihu.com/question/48312588/answer/3034670442</a></p>
]]></content>
      <categories>
        <category>question</category>
      </categories>
  </entry>
  <entry>
    <title>一些问题</title>
    <url>/2023/05/19/someQuestions/Questions-0/</url>
    <content><![CDATA[<p>记录一些想到的问题</p>
<h2 id="1-什么是Java方法重写"><a href="#1-什么是Java方法重写" class="headerlink" title="1.什么是Java方法重写"></a>1.什么是Java方法重写</h2><p>要求遵循“两同两大一小”</p>
<ul>
<li>“两同” 指方法名相同，形参列表相同</li>
<li>“两小” 指子类方法返回值类型应该比父类返回值类型更小，子类方法声明抛出的异常类应该比父类方法抛出的更小或者相等</li>
<li>“一大” 指子类方法的访问权限应该比父类方法的访问权限更大或者相等。<span id="more"></span>
这是因为如果返回值类型更大，则可能会造成父类对象无法完全转换为子类对象，从而导致编译错误和运行时异常。<br>重写还有一条规则是访问控制符必须高于父类？那是因为为了多态的实现。有时候父类需要上转型引用子类的方法实现多态，这就导致子类方法的访问控制符必须高于父类，否则子类里写成了private，父类还怎么访问？</li>
</ul>
<h2 id="2-对象实例都在Java堆中吗？"><a href="#2-对象实例都在Java堆中吗？" class="headerlink" title="2.对象实例都在Java堆中吗？"></a>2.对象实例都在Java堆中吗？</h2><p>不一定，是几乎所有的实例都在堆中。<br>JIT编译除了具有缓存的功能外，还会对代码做各种优化，其中有逃逸分析功能。<br>如果逃逸分析发现一个对象不会逃逸出当前方法或线程，则可以将该对象存储在栈上而不是堆上。由于栈是局部的，存储在栈上的对象只能由当前方法或线程访问，这样就减少了对内存的分配和垃圾回收的工作量，从而提高了程序的性能。<br>可以通过 -XX:+DoEscapeAnalysis 指定是否进行逃逸分析。</p>
<p>参考：<br><a href="http://www.hollischuang.com/archives/2398">http://www.hollischuang.com/archives/2398</a></p>
<h2 id="3-接口和抽象类的共同点和区别"><a href="#3-接口和抽象类的共同点和区别" class="headerlink" title="3.接口和抽象类的共同点和区别"></a>3.接口和抽象类的共同点和区别</h2><p>共同点:</p>
<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现的方法</li>
</ul>
<p>区别：</p>
<ul>
<li>接口是对类的行为进行约束，实现了某个接口就有了对应的行为，抽象类主要用于代码复用，强调的是所属关系</li>
<li>类只能继承一个类，但可以实现多个接口</li>
<li>接口中的成员变量只能是<code>public static final</code>,抽象类的成员变量默认<code>defalut</code></li>
</ul>
<h2 id="4-解决哈希冲突的办法"><a href="#4-解决哈希冲突的办法" class="headerlink" title="4.解决哈希冲突的办法"></a>4.解决哈希冲突的办法</h2><ul>
<li><p>开放地址法<br>开放地址法是指当发生哈希冲突时，继续在哈希表中查找空闲的位置，直到找到一个空闲的位置为止。其中包括线性探测、二次探测等技术。</p>
</li>
<li><p>链表法<br>链表法是指每个哈希值对应一个链表，如果发生哈希冲突，则将新的元素加入到对应位置的链表中。</p>
</li>
<li><p>再哈希法<br>再哈希法是指在第一次哈希之后，如果出现冲突，则再次进行哈希，直到找到合适的位置。</p>
</li>
<li><p>建立公共溢出区<br>建立公共溢出区是指将所有冲突的元素都存储在同一个溢出区，并通过某种方式来确定元素在该区域中的位置。</p>
</li>
</ul>
<h2 id="5-String-StringBulider-，StringBuffer"><a href="#5-String-StringBulider-，StringBuffer" class="headerlink" title="5.String,StringBulider ，StringBuffer"></a>5.String,StringBulider ，StringBuffer</h2><p>先看后两者：<br>共同点：</p>
<ul>
<li><p><code>StringBulider</code>和<code>StringBuffer</code>都继承了<code>AbstractStringBuilder</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line"><span class="type">byte</span>[] value;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>区别：</p>
<ul>
<li>StringBuffer线程安全，StringBulider非线程安全。</li>
</ul>
<p><code>String</code>不可变的真正原因：</p>
<ul>
<li>整个类被final修饰，确保不会被继承，防止被子类修改byte数组。</li>
<li>byte数组的修饰符为<code>private final</code> ，同时没有提供修改的方法。</li>
</ul>
<h2 id="6-Java对象的创建过程"><a href="#6-Java对象的创建过程" class="headerlink" title="6.Java对象的创建过程"></a>6.Java对象的创建过程</h2><ol>
<li><p>类加载：<br> 检查能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析、初始化过、如果没有，必须先执行相应的类加载过程</p>
</li>
<li><p>在堆中分配内存：</p>
<ul>
<li>划分可用空间：<br>  指针碰撞：Serial,ParNew等带Compact过程的收集器时<br>  空闲列表：CMS基于Mark-Sweep算法的收集器</li>
<li>线程安全：<br>  CAS + 失败重试的方法<br>  TLAB: 每个线程预先分配一小块内存</li>
</ul>
</li>
<li><p>将分配的内存初始化为0：</p>
</li>
<li><p>设置对象头的必要设置：<br> GC年代，对象的Hash码等</p>
</li>
<li><p>执行init方法：<br> 按程序员意愿初始化</p>
</li>
</ol>
<h2 id="7-红黑树"><a href="#7-红黑树" class="headerlink" title="7.红黑树"></a>7.红黑树</h2><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>结点是红色或黑色；</li>
<li>根结点是黑色。</li>
<li>叶子结点（也叫外部结点、NULL结点、失败结点）是黑色。</li>
<li>不存在两个相邻的红结点。（即红结点的父结点和子结点都是黑色的）</li>
<li>从任意结点到可达的叶子结点的每个路径包含相同数目的黑色节点。</li>
</ol>
<p>速记：左根右，根叶黑，不红红，黑路同。（源自王道）</p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><ol>
<li>先查找，确定插入位置，原理同二叉查找树，</li>
<li>新结点是根，则是黑色<br> 新结点非根，则是红色</li>
<li>若不满足要求，则进行调整<br> 黑叔：旋转 + 染色<br> LL型：右单旋，父换爷，染色<br> RR型：左单旋，父换爷，染色<br> LR型： 左右双旋，儿换爷，染色<br> RL型：右，左双旋，儿换爷，染色<br> 红叔：染色 + 变新<br> 叔父爷染色，爷变为新结点</li>
</ol>
<h2 id="8-线程和进程的区别？"><a href="#8-线程和进程的区别？" class="headerlink" title="8.线程和进程的区别？"></a>8.线程和进程的区别？</h2><p>（1）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。</p>
<p>（2）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。<br>注意：TLB,MMU将虚拟地址转换成物理地址，虚拟地址和物理地址的映射存储在页表中，根据时间局部性和空间局部性，专门设置了TLB将经常使用的映射存储在TLB中。</p>
<h2 id="9-死锁的解决办法"><a href="#9-死锁的解决办法" class="headerlink" title="9. 死锁的解决办法"></a>9. 死锁的解决办法</h2><p>破坏四个必要条件：互斥、占有等待、不可抢占、循环等待</p>
<ul>
<li>占有等待条件，死锁预防：<br>  进程开始前，必须一次性获得所有资源，否则不许执行</li>
<li>不可抢占，</li>
<li>循环等待：<br>  将资源编号，只能申请序号更大的资源</li>
</ul>
<p>银行家算法，分配举证，最大需求矩阵，需求矩阵。</p>
]]></content>
      <categories>
        <category>question</category>
      </categories>
  </entry>
</search>
